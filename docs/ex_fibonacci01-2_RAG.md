# RAG示例
> 讲述与分析对代码做嵌入的策略，保证LLM预测之前，得到的prompt有价值，且上下文不长；


- 原始代码
```cint fibonacci(int n) {
    if (n < 1) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n-1) + fibonacci(n-2);
    }
}

int main() {
    int x = __VERIFIER_nondet_int();
    if (x > 46) return 0;
    if (x < 1) return 0;
    int result = fibonacci(x);
    // ... assertions ...
}
```

- AST
```yaml
FuncDef: fibonacci
  Decl: n (int)
  Body:
    If:
      Cond: BinaryOp(<, n, 1)
      True: Return(0)
      False:
        If:
          Cond: BinaryOp(==, n, 1)
          True: Return(1)
          False: Return(
            BinaryOp(+,
              FuncCall(fibonacci, BinaryOp(-, n, 1)),
              FuncCall(fibonacci, BinaryOp(-, n, 2))
            )
          )
```

- CFG
```yaml
[Block 1: Entry]
  |
  v
[Block 2: if (n < 1)] --True--> [Block 3: return 0]
  | False
  v
[Block 4: if (n == 1)] --True--> [Block 5: return 1]
  | False
  v
[Block 6: Call fib(n-1)]
  |
  v
[Block 7: Call fib(n-2)]
  |
  v
[Block 8: Add & Return]
```

- NL Summary
```
A recursive function that calculates the n-th Fibonacci number. It has two base cases for n < 1 and n == 1. The recursive step calls itself twice with n-1 and n-2. The main function calls this with a bounded input x (1 <= x <= 46).
```

- Symbolic Feature Vector
    特征维度	值	解释
    has_loop	0	无显式循环
    has_recursion	1	存在递归调用
    is_linear	1	变量更新是线性的 (n-1, n-2)
    has_upper_bound	1	main 中有 x > 46 检查
    has_lower_bound	1	main 中有 x < 1 检查
    complexity_class	2	(假设 0=O(1), 1=O(n), 2=O(2^n))
向量化表示：[0, 1, 1, 1, 1, 2]


## 多源RAG示意
```json
{
  "case_id": "Fibonacci01-2",
  "source_file": "data/SVC25_c/Fibonacci01-2.c",
  "code": "int fibonacci(int n) { ... } ...", 
  "label": "terminating",
  "explanation": "Recursive calls strictly decrease the argument 'n', and base cases 'n<1' and 'n==1' ensure termination.",
  
  "rag_views": {
    "structure_view": {
      "description": "Canonicalized code for structural similarity",
      "content": "int f1(int v1) { if (v1 < 1) return 0; ... }",
      "embedding": [-0.12, 0.05, 0.88, ...]  // Generated by CodeBERT from canonical code
    },
    
    "semantic_view": {
      "description": "NL summary for logic similarity",
      "content": "Recursive Fibonacci calculation with bounded input range [1, 46].",
      "embedding": [0.02, -0.44, 0.15, ...]   // Generated by Text-Embedding-v3 from summary
    },
    
    "symbolic_view": {
      "description": "Hand-crafted features for filtering",
      "features": {
        "has_recursion": true,
        "has_loop": false,
        "variable_update": "decrement",
        "input_bounded": true
      },
      "feature_vector": [0, 1, 1, 1, 1, 2]
    }
  },

  "metadata": {
    "provider": "qwen",
    "models": {
      "structure": "codebert-base",
      "semantic": "text-embedding-v4"
    },
    "last_updated": "2025-11-21T10:00:00Z"
  }
}
```