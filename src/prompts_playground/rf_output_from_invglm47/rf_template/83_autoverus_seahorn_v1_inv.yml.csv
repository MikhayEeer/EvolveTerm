timestamp,experiment_name,target_file,source_path,source_file,loop_id,prompt_version,config_tag,model,temperature,top_p,max_tokens,latency_ms,prompt_tokens,completion_tokens,total_tokens,template_type,template_depth,parsed_configuration,raw_response_snippet
2026-01-19T00:46:03.886566,rf_template_Deterministic,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template,glm47,glm-4.7,0.0,1.0,,4217.15,293,255,548,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""A single ranking function (-x) is sufficient as x strictly increases towards 0. 'lnested' with depth 1 represents a single component ranking function.""}","analysis: |   The loop condition is `(x < 0)`, and the loop body updates `x` and `y` such that `x` increases by `y` and `y` increments by 1 in each iteration.      Although `y` increases monotonically"
2026-01-19T00:46:13.102804,rf_template_Balanced,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template,glm47,glm-4.7,0.7,0.9,,9213.62,293,458,751,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""The variable x increases monotonically (x' = x + y) towards the loop exit condition x >= 0. The ranking function r = -x decreases strictly as long as y > 0.""}",analysis: |   The loop condition is `(x < 0)`. The loop body updates `x` to `x + y` and `y` to `y + 1`.   Given the invariants `x >= 0` and `y >= 0` (which likely hold outside the loop or are intended
2026-01-19T00:46:18.817404,rf_template_Creative,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template,glm47,glm-4.7,1.0,1.0,,5712.3,293,353,646,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""The variable x increases monotonically (x = x + y) while y is non-negative, so -x decreases strictly until the condition x < 0 becomes false.""}","analysis: |   The loop condition is `x < 0`. The loop updates variables `x` and `y` according to `x = x + y` and `y = y + 1`.   Given the invariants state `x >= 0` and `y >= 0`, if `x` were negative i"
2026-01-19T00:46:19.895214,rf_template_autoverus_seahorn_v1_Deterministic,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.0,1.0,,1077.09,256,14,270,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-19T00:46:20.886783,rf_template_autoverus_seahorn_v1_Balanced,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.7,0.9,,990.7,256,14,270,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-19T00:46:21.852950,rf_template_autoverus_seahorn_v1_Creative,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,1.0,1.0,,965.26,256,14,270,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-19T00:46:24.753818,rf_template_fewshot_Deterministic,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_fewshot,glm47,glm-4.7,0.0,1.0,,2899.2,501,181,682,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""Single variable monotone decrease (x decreases as y >= 0).""}","analysis: |   The loop condition is `(x < 0)`. Inside the loop, `x` decreases (since `x = x + y` and `y >= 0`), while `y` increases (`y = y + 1`). The invariants state `y >= 0`, confirming that `y` is"
2026-01-19T00:46:31.028798,rf_template_fewshot_Balanced,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_fewshot,glm47,glm-4.7,0.7,0.9,,6273.09,501,214,715,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""Single variable x increases monotonically towards the loop exit condition.""}","analysis: |   The loop continues while `x < 0`. Inside the loop, `x` is updated to `x + y` and `y` is incremented by 1.   Given the invariants `x >= 0` and `y >= 0` (likely holding in a wider context "
2026-01-19T00:46:35.905680,rf_template_fewshot_Creative,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_fewshot,glm47,glm-4.7,1.0,1.0,,4874.86,501,235,736,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""Single variable x increases monotonically toward the bound 0.""}","analysis: |   The loop exits when x becomes non-negative ($x \ge 0$).   Inside the loop, we assume $x < 0$.   The update rule is $x \leftarrow x + y$ and $y \leftarrow y + 1$.   With the invariant $y "
2026-01-19T04:12:23.995697,rf_template_Deterministic,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template,qwenplus,qwen-plus,0.0,1.0,,45319.18,300,2048,2348,,,"{""analysis"": ""The loop condition is (x < 0), so the loop continues while x is negative.\nInside the loop:\n  - x is updated as x = x + y\n  - y is updated as y = y + 1\n\nWe analyze the behavior of variables:\n- y starts from some initial value (possibly negative, but not known to be bounded below).\n- However, since y increases by 1 in each iteration (y = y + 1), it exhibits strictly increasing behavior.\n- The update of x depends on y: x = x + y. As y increases over time, the increment to x becomes larger in each step.\n\nTo prove termination, we need to show that eventually x >= 0.\n\nConsider the dynamics:\n- Even if y is initially negative, after a finite number of steps, y will become non-negative and then positive.\n- Once y becomes positive and keeps growing, x will start increasing at an accelerating rate.\n- Since y increments linearly, after k steps, y grows like O(k), and x accumulates these values — thus x grows quadratically (sum of an arithmetic progression).\n\nTherefore, x will eventually exceed any fixed bound (including 0) in finite time, ensuring termination.\n\nNow for ranking function design:\n- A single expression involving both x and y is needed.\n- Because progress is not linear or uniform in one variable alone, but rather emerges from the combined evolution of x and y, a lexicographic ranking function may help.\n\nHowever, note:\n- y increases monotonically => y itself progresses toward making x increase faster.\n- x may decrease initially (if y is negative), but eventually increases due to growing y.\n- Hence, long-term progress is driven by the combination.\n\nBut crucially: there is no phase change or alternating behavior; the updates are uniform throughout.\nFurthermore, although two variables evolve, they do so in a way that jointly ensures x reaches non-negativity.\n\nInsight:\nLet’s consider a ranking function based on how far x is from 0, adjusted by the current value of y.\nHowever, since y increases and helps “accelerate” x upward, we can bound the number of iterations until x ≥ 0.\n\nActually, this loop can be bounded by a *quadratic* ranking function. But for SVMRanker, we seek simple templates.\n\nCan we use a lexicographic ranking?\n\nTry depth-2 lexicographic:\n  R = (r1, r2)\nPossibility:\n  r1 could be something that decreases when y is negative (e.g., -y if y < 0), and\n  r2 could be related to distance from x to 0.\n\nBut control flow doesn’t switch phases explicitly.\n\nAlternatively, observe:\n- y increases without bound (unless constrained, but no such invariant suggests it's bounded).\n- Eventually, even if x starts very negative, the accumulated effect of increasing y will push x to ≥ 0.\n\nHowever, instead of multi-phase reasoning, the entire process is governed by monotonic improvement in a compound metric.\n\nBut here's the key: **no variable decreases monotonically**, so a single-rank component won't suffice unless it's a complex expression.\n\nHowever, SVMRanker handles predefined templates.\n\nGiven the structure:\n  - y increases by 1 → this is linear and monotonic.\n  - x increases by y, which itself increases → super-linear growth in x.\n\nWe can reason about termination using a **lexicographic ranking function** where:\n  Component 1: An upper bound on the number of steps until y ≥ 0 (i.e., -y when y < 0)\n  Component 2: The number of steps needed for x to reach ≥ 0 given current y\n\nBut actually, once y ≥ 0, then x increases by at least y ≥ 0, and y keeps growing → x will grow fast.\n\nSo potential phases:\n  Phase 1: y < 0 → x may decrease or increase slowly\n  Phase 2: y ≥ 0 → x increases and accelerates\n\nThis suggests a **multi-phase** behavior: while y < 0, we are in one regime; once y ≥ 0, another begins.\n\nIn phase 1: y increases toward 0 → finite number of steps (-y steps if y integer)\nIn phase 2: x increases by at least y, which is now non-decreasing → x will reach 0 in finite additional steps.\n\nThus, we can model this with two phases:\n  - First, wait for y ≥ 0 (bounded by initial -y if y<0)\n  - Then, compute how many more steps until x ≥ 0\n\nTherefore, this fits a **multi-phase (lmulti)** pattern with depth 2.\n\nHowever, note: the loop condition is only on x, and y evolves independently.\n\nBut the progress differs qualitatively depending on whether y is negative or not.\n\nTherefore, lmulti with depth=2 is suitable.\n\nBut wait: is phase switching explicit? Not syntactically, but logically yes — when y crosses zero.\n\nSo we can define:\n  Phase 1: y < 0 → measure: -y (decreasing because y increases)\n  Phase 2: y >= 0 → measure: some decreasing function related to x reaching 0\n\nExample ranking during phase 2: let d = ceil((1 - 2*x)/ (2*y + 1)) ??? Too complex.\n\nSimpler idea: once y ≥ 0, then in each step:\n  x_{n+1} = x_n + y_n\n  y_{n+1} = y_n + 1\n\nSo x grows at least linearly (actually quadratically). The number of steps needed for x to reach 0 from negative value is finite.\n\nBut to capture this in SVMRanker, we don't need exact formula — just the template.\n\nSince there are two distinct regimes of behavior separated by a threshold on y, and different measures apply in each, **lmulti** with depth 2 is appropriate.\n\nHowever, note that lmulti is intended for loops that clearly go through phases — e.g., first modify one variable, then another.\n\nHere, the same statements execute throughout. But the *effect* changes.\n\nAlternative: use lnested(2): lexicographic tuple.\n\nLet’s try to build a lexicographic ranking function:\n\n  Let r1 = -y   [when y < 0] — but this would increase, not decrease.\n\nInstead, think: what decreases?\n\nIdea:\n  When y ≤ 0: x increases by y (≤0), so x might not help. But y increases → so \""time until y > 0\"" decreases.\n\n  Let T1 = max(0, floor(-y) + 1) → steps until y ≥ 1.\n\n  But again, we want a measure that decreases.\n\n  Define m1 = max(0, -y) → this decreases by 1 each step while y < 0.\n\n  While m1 > 0, m1 decreases by 1 per iteration.\n\n  When m1 = 0 (i.e., y ≥ 0), then x increases by y ≥ 0, and y increases further.\n\n  Then define m2 = number of steps needed for x to reach ≥ 0 assuming worst-case? Or simply use a function of x and y.\n\n  Note: once y ≥ 0, then x will increase by at least y, then y+1, etc.\n\n  The minimal future increase in x starting from current x < 0 is:\n    After k steps: x_final = x + sum_{i=0}^{k-1} (y + i) = x + k*y + k*(k-1)/2\n\n  We want smallest k such that x + k*y + k(k-1)/2 ≥ 0.\n\n  This k is bounded and decreases as we take steps.\n\n  But k is not linear.\n\nHowever, for ranking functions, we don’t need exact k — just a well-founded measure that decreases.\n\nBut SVMRanker uses templates — likely linear or simple expressions.\n\nGiven complexity, perhaps **lnested(2)** with:\n  Component 1: max(0, -y)  → decreases while y < 0\n  Component 2: some function that bounds steps needed for x ≥ 0, e.g., a quadratic form\n\nBut again, templates are limited.\n\nAnother idea: use a single measure based on potential.\n\nConsider candidate: V = max(0, -y) * C + W(x,y)\n\nBut nested tuples are easier.\n\nStandard technique: use lexicographic pair (a, b) where:\n  a = -y          [as long as y < 0]\n  b = -x          [but -x may increase or decrease]\n\nNo — when y < 0, x = x + y → x decreases → -x increases → not decreasing.\n\nNot good.\n\nWhat decreases?\nNothing obvious globally.\n\nBut: eventually y becomes non-negative, and then x increases to 0.\n\nSo the loop has two stages:\n  Stage 1: y < 0 → duration bounded by initial -y\n  Stage 2: y >= 0 → duration bounded by solution to quadratic inequality\n\nSince the behavior and dominant progress metric change between stages, and we have clear switching point (y >= 0), this supports **lmulti**.\n\nMoreover, in stage 1, the ranking is essentially the remaining steps until y >= 0.\nIn stage""}","```yaml analysis: |   The loop condition is (x < 0), so the loop continues while x is negative.   Inside the loop:     - x is updated as x = x + y     - y is updated as y = y + 1    We analyze the beh"
2026-01-19T04:12:44.587126,rf_template_Balanced,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template,qwenplus,qwen-plus,0.7,0.9,,20585.85,300,967,1267,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct phases: first, y increases until it becomes positive; second, x increases until it reaches 0. A multi-phase ranking function with depth 2 captures this behavior naturally, measuring progress first by -y and then by -x.""}","```yaml analysis: |   The loop condition is (x < 0), meaning the loop continues while x is negative.   Inside the loop:     - x is updated as x = x + y     - y is updated as y = y + 1    We analyze th"
2026-01-19T04:13:10.012257,rf_template_Creative,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template,qwenplus,qwen-plus,1.0,1.0,,25419.74,300,1094,1394,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""The loop exhibits monotonic progress: y increases by 1 each iteration, and x increases by y, which grows over time. This ensures x eventually becomes non-negative, guaranteeing termination. A single-component lexicographic ranking function suffices to capture this steady advancement.""}","```yaml analysis: |   The loop runs while (x < 0). Inside the loop, x is updated as (x + y) and y is incremented by 1.    Initial values are not provided, but we analyze the behavior assuming entry in"
2026-01-19T04:13:11.024227,rf_template_autoverus_seahorn_v1_Deterministic,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.0,1.0,,1011.42,263,14,277,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-19T04:13:11.866962,rf_template_autoverus_seahorn_v1_Balanced,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.7,0.9,,841.89,263,14,277,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-19T04:13:12.820446,rf_template_autoverus_seahorn_v1_Creative,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,1.0,1.0,,952.54,263,14,277,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-19T04:13:18.818294,rf_template_fewshot_Deterministic,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_fewshot,qwenplus,qwen-plus,0.0,1.0,,5995.81,511,223,734,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""The loop guard (x < 0) is incompatible with the invariant (x >= 0), so the loop never executes. Termination is trivial. A minimal ranking function (e.g., constant 0) suffices, hence lnested with depth 1.""}","```yaml analysis: |   The loop condition is (x < 0), but the invariants state that x >= 0 and y >= 0.   This implies that the loop body is never executed, because the precondition (x < 0) contradicts "
2026-01-19T04:13:57.538828,rf_template_fewshot_Balanced,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_fewshot,qwenplus,qwen-plus,0.7,0.9,,38717.6,511,2048,2559,,,"{""analysis"": ""The loop condition is (x < 0), and the loop body updates x := x + y and y := y + 1.\nHowever, the provided invariants include \""x >= 0\"", which contradicts the loop condition (x < 0).\nThis suggests that either:\n  - The loop never executes (if initially x >= 0), or\n  - The invariants are incorrect/post-loop properties, not in-loop invariants.\n\nAssuming the loop can execute, then initially x < 0 must hold. During execution:\n  - y increases monotonically (y := y + 1), so y is strictly increasing.\n  - x is updated as x := x + y. Since y increases each iteration, the increment to x grows over time.\n\nEven though x may start negative, eventually the growing y will cause x to increase and possibly become non-negative, at which point the loop terminates.\n\nThus, the key observation is that although x may decrease initially (if y is negative), the invariant says y >= 0, so y is non-negative and increasing.\n\nGiven y >= 0 and increasing, and x being updated by adding y, x will eventually stop being negative — so progress is made toward termination via a combination of x and y.\n\nHowever, x itself does not decrease monotonically; it increases (or becomes less negative) over time due to positive increments from growing y. So we are making monotonic progress in a single phase: both y and the value of x are trending upward, and termination occurs when x reaches 0 or above.\n\nSince only one measure — eventual growth of x due to cumulative positive increments — drives termination, and all variables involved are progressing in a way that supports this (y increasing, thus accelerating x's growth), a single ranking function suffices.\n\nTherefore, a lexicographic ranking of depth 1 is sufficient because we can construct a linear combination (e.g., something like -x when y > 0) that decreases (i.e., x increases toward 0).\n\nBut note: since x starts negative and increases toward 0, -x decreases toward 0 — so -x is a decreasing quantity bounded below by 0. If we can bound the number of iterations until x >= 0, then -x (when x < 0) acts as a ranking function.\n\nHowever, if y starts at 0, then x := x + 0 = x — no progress. But invariant says y >= 0, but not that y > 0. So consider:\n\n  - If y == 0 initially, then x never changes → infinite loop if x < 0.\n  - But invariant says y >= 0, and y := y + 1 → so y increases every iteration.\n\nWait! y := y + 1 means y increases by 1 each iteration → so even if y starts at 0, next it becomes 1, then 2, etc.\n\nSo y is strictly increasing by 1 each iteration → y grows linearly.\n\nThen x is updated as x := x + y_old, where y_old is the current value before increment.\n\nSo sequence:\n  Iteration 1: x₁ = x₀ + y₀, y₁ = y₀ + 1\n  Iteration 2: x₂ = x₁ + y₁ = x₀ + y₀ + (y₀ + 1) = x₀ + 2y₀ + 1\n  etc.\n\nSo x grows quadratically if run long enough.\n\nSince y increases without bound and x accumulates increasing values, once x starts being incremented by positive amounts, it will eventually become ≥ 0.\n\nBut initially, y might be negative? No — invariant says y >= 0.\n\nSo y ≥ 0 and increases by 1 each iteration → y ≥ k after k iterations.\n\nThen the increment to x in iteration i is y_i ≥ 0, and strictly increasing.\n\nSo x undergoes increasing positive jumps. Starting from x < 0, after finite steps, x will exceed 0.\n\nHence, termination is guaranteed.\n\nCan we find a ranking function?\n\n  Let’s define potential: ρ = (-x) if x < 0, else 0. But it's not linear.\n\nAlternatively, observe that y increases by 1 each time → y acts as a counter.\n\nAnd x increases by at least min(y, y+1, ...) but y grows.\n\nActually, since y increases without bound and x accumulates increasingly large positive terms, the process must terminate.\n\nHowever, no single variable decreases monotonically. Instead, we can use a ranking function combining x and y.\n\nBut note: we don't need complex reasoning — the system can use a linear ranking function template.\n\nSince all transitions are linear and the loop terminates due to eventual positivity of x driven by growing y, and given that y increases steadily while x improves in larger steps, a single-component lexicographic ranking (depth 1) using a linear function like -(x) + c*(-y) won’t work directly since both x and y increase.\n\nWait: we want a function that decreases.\n\nLet’s think: could we use a function like f(x, y) = -x? But x increases → so f decreases → good.\n\nBut only if -x is bounded below by 0 during loop execution? When x < 0, -x > 0. As x increases (becomes less negative), -x decreases → yes.\n\nSo while x < 0, -x is a positive decreasing quantity. Each iteration adds y to x → so Δ(-x) = -Δx = -y.\n\nSo -x decreases by y each iteration.\n\nBut y ≥ 0 and increases → so the step size is non-negative → -x decreases by at least 0 (but more as y grows).\n\nHowever, for ranking, we need strict decrease? Not necessarily — but we need eventual drop to below zero.\n\nProblem: if y = 0, then Δ(-x) = 0 → no decrease.\n\nBut wait: even if y = 0, after assignment: x := x + 0 = x, then y := y + 1 → y becomes 1.\n\nSo next iteration, y = 1 → x gets increased by 1.\n\nSo although in one iteration x doesn't change, y does, and future progress is ensured.\n\nBut ranking functions usually require descent every iteration.\n\nSo we cannot use -x alone — because if y=0, x doesn't change → -x stays same → not strictly decreasing.\n\nHowever, y increases every iteration → so y is strictly increasing.\n\nSo consider using a lexicographic pair: ( -x , -y )? No — both aren't decreasing.\n\nInstead: what about (some measure that captures distance to termination)?\n\nAlternative idea: use a multi-phase approach.\n\nPhase 1: while y ≤ Y₀ (no — y increases)\n\nOr: since y increases indefinitely, and x receives increasingly large boosts, we might model this with a quadratic ranking function.\n\nBut SVMRanker supports only lnested and lmulti with linear components.\n\nLet's reconsider:\n\n  The state evolves as:\n    x' = x + y\n    y' = y + 1\n\n  This is an affine transition.\n\n  We seek a linear function f(x,y) = a*x + b*y + c such that:\n    f(x',y') < f(x,y) for all states with x < 0\n    and f(x,y) ≥ 0 when x ≥ 0 (termination condition)\n\n  But f(x',y') = a*(x+y) + b*(y+1) + c = a*x + a*y + b*y + b + c = a*x + (a + b)*y + (b + c)\n\n  We want:\n    a*x + (a + b)*y + (b + c) < a*x + b*y + c\n    ⇒ (a + b)*y + b + c < b*y + c\n    ⇒ a*y + b < 0\n\n  So we need: a*y + b < 0 for all y in reachable states with x < 0.\n\n  But y ≥ 0 and can grow arbitrarily — unless the loop terminates quickly.\n\n  Suppose a < 0 — then a*y → -∞ as y grows → but we need uniform inequality for all y? No — just for reachable ones.\n\n  But reachable y starts from some initial y₀ ≥ 0 and increases by 1 per step.\n\n  However, if a < 0, then for large y, a*y + b becomes very negative — good.\n\n  But for small y, say y=0, we need b < 0.\n\n  But let's try: suppose a = -1, b = -1.\n\n  Then condition: -y -1 < 0 → true for all y ≥ 0.\n\n  So f(x,y) = -x - y\n\n  Then:\n    f(x',y') = - (x+y) - (y+1) = -x - y - y - 1 = -x -2y -1\n    f(x,y) = -x - y\n    Difference: f' - f = (-x -2y -1) - (-x - y) = -y -1 < 0 → always decreases.\n\n  Now check lower bound: when x >= 0, we want f(x,y) >= 0? Not necessarily — ranking function needs to be bounded below and decrease by at least a minimum amount each step.\n\n  But f(x,y) = -x - y → when x < 0 and y ≥""}","```yaml analysis: |   The loop condition is (x < 0), and the loop body updates x := x + y and y := y + 1.   However, the provided invariants include ""x >= 0"", which contradicts the loop condition (x <"
2026-01-19T04:14:07.969608,rf_template_fewshot_Creative,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_fewshot,qwenplus,qwen-plus,1.0,1.0,,10427.62,511,488,999,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""The loop guard (x < 0) contradicts the invariant x >= 0, so the loop never executes. Termination is trivial. A minimal ranking template suffices.""}","```yaml analysis: |   The loop condition is (x < 0), but the invariants state that x >= 0 and y >= 0.   This means the loop body is never executed, as the condition x < 0 is false from the start under"
2026-01-19T09:40:30.882189,rf_template_Deterministic,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template,qwenmax,qwen3-max,0.0,1.0,,19718.93,300,674,974,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two phases: first, y increases until it becomes positive; then x increases toward non-negative. A 2-phase multi-phase ranking function captures this behavior.""}","```yaml analysis: |   The loop condition is (x < 0), so the loop continues as long as x is negative.   In each iteration:     x := x + y     y := y + 1    From the invariants, we know that eventually "
2026-01-19T09:41:10.430611,rf_template_Balanced,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template,qwenmax,qwen3-max,0.7,0.9,,39542.43,300,1434,1734,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop has two phases: (1) when y=0, x doesn't change but y increases; (2) when y>=1, x increases steadily. A multi-phase ranking function with depth 2 captures this behavior.""}","```yaml analysis: |   The loop condition is (x < 0), so the loop continues as long as x is negative.   In each iteration:     x := x + y     y := y + 1    From the invariants, we know that y >= 0 hold"
2026-01-19T09:41:42.746788,rf_template_Creative,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template,qwenmax,qwen3-max,1.0,1.0,,32311.71,300,1378,1678,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop has two phases: (1) y may start at 0, causing x to remain unchanged while y increments to 1; (2) once y ≥ 1, x increases by at least 1 per iteration until x ≥ 0. This matches a 2-phase multiphase ranking function.""}","```yaml analysis: |   The loop condition is (x < 0), so the loop executes while x is negative.   Inside the loop:     x := x + y     y := y + 1    Note that y increases by 1 each iteration, so y is st"
2026-01-19T09:41:43.991116,rf_template_autoverus_seahorn_v1_Deterministic,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.0,1.0,,1243.38,263,14,277,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-19T09:41:45.511504,rf_template_autoverus_seahorn_v1_Balanced,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.7,0.9,,1519.39,263,14,277,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-19T09:41:46.786616,rf_template_autoverus_seahorn_v1_Creative,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,1.0,1.0,,1274.17,263,14,277,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-19T09:42:05.825335,rf_template_fewshot_Deterministic,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_fewshot,qwenmax,qwen3-max,0.0,1.0,,19035.09,511,696,1207,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""A linear ranking function such as -x (or -x + y) decreases after at most one iteration; monotonic progress ensures termination with depth 1.""}","```yaml analysis: |   The loop condition is (x < 0), so the loop runs while x is negative.   However, the provided invariants state ""x >= 0"" and ""y >= 0"", which seems contradictory at first glance.   "
2026-01-19T09:42:36.870281,rf_template_fewshot_Balanced,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_fewshot,qwenmax,qwen3-max,0.7,0.9,,31039.63,511,1045,1556,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: (1) y=0 (at most one iteration, y increases), (2) y≥1 and -x decreases as x increases toward non-negativity.""}","```yaml analysis: |   The loop condition is (x < 0), so the loop runs while x is negative.   Inside the loop, x is updated as x = x + y, and y = y + 1.   Given the invariants include y >= 0, and initi"
2026-01-19T09:43:36.576525,rf_template_fewshot_Creative,83_autoverus_seahorn_v1_inv.yml,loop_invariants/code2inv/83.c,83_pmt_yamlv2_extract.yml,1,rf_template_fewshot,qwenmax,qwen3-max,1.0,1.0,,59698.63,511,2052,2563,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first phase handles y=0 (x unchanged, y increases to 1), second phase x increases by at least 1 per iteration until x >= 0.""}","```yaml analysis: |   The loop condition is (x < 0), so the loop runs while x is negative.   Inside the loop: x := x + y, and y := y + 1.   Given the invariants include x >= 0 and y >= 0, these must h"
