timestamp,experiment_name,target_file,source_path,source_file,loop_id,prompt_version,config_tag,model,temperature,top_p,max_tokens,latency_ms,prompt_tokens,completion_tokens,total_tokens,template_type,template_depth,parsed_configuration,raw_response_snippet
2026-01-16T17:20:21.945340,rf_template_Deterministic,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template,glm47,glm-4.7,0.0,1.0,,26530.45,267,1456,1723,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""A single lexicographic component defined by -x - y*(y+1)/2 strictly decreases when y >= 0, ensuring termination.""}","analysis: |   The loop condition is `x < 0`.   Inside the loop, the updates are:   1. `x = x + y`   2. `y = y + 1`    Let's analyze the effect on `x`. Substituting the update of `y` into the update of"
2026-01-16T17:20:29.308911,rf_template_Balanced,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template,glm47,glm-4.7,0.7,0.9,,7361.02,267,445,712,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""The variable x increases monotonically (specifically, x increases every two steps once y becomes non-negative) towards the bound 0. Since termination depends on the increase of a single variable, a simple lexicographic ranking with depth 1 is sufficient.""}","analysis: |   The loop condition is `x < 0`. Inside the loop, `x` is updated to `x + y`, and `y` is updated to `y + 1`.      We can analyze the change in `x` over two iterations to determine monotonic"
2026-01-16T17:20:37.320668,rf_template_Creative,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template,glm47,glm-4.7,1.0,1.0,,8008.8,267,551,818,lmulti,1,"{""type"": ""lmulti"", ""depth"": 1, ""explanation"": ""The loop has a single phase of execution where y strictly increases. The variable x is updated by y, creating a dependent progression. The ranking type is lmulti to capture the single phase of increasing y.""}",```yaml analysis: |   The loop condition is `x < 0`. The loop body updates `x` as `x = x + y` and `y` as `y = y + 1`.   The variable `y` strictly increases with every iteration (`y' = y + 1`).   The v
2026-01-16T17:20:39.043202,rf_template_autoverus_seahorn_v1_Deterministic,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.0,1.0,,1721.57,230,14,244,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T17:20:40.112530,rf_template_autoverus_seahorn_v1_Balanced,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.7,0.9,,1068.39,230,14,244,lmulti,1,"{""type"": ""lmulti"", ""depth"": 1}","configuration:   type: ""lmulti""   depth: 1"
2026-01-16T17:20:41.113124,rf_template_autoverus_seahorn_v1_Creative,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,1.0,1.0,,999.65,230,14,244,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T17:20:49.534036,rf_template_fewshot_Deterministic,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_fewshot,glm47,glm-4.7,0.0,1.0,,8418.0,475,560,1035,lnested,2,"{""type"": ""lnested"", ""depth"": 2, ""explanation"": ""Quadratic decrease requires composite ranking (e.g., x - y^2/2). Depth 2 allows capturing this relationship where y progresses while defining the bound for x.""}","analysis: |   The loop condition depends on variable `x`. While `x` is negative, `x` is updated by adding `y`, and `y` is incremented by 1.      To express the decrease required for termination, consi"
2026-01-16T17:20:52.370011,rf_template_fewshot_Balanced,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_fewshot,glm47,glm-4.7,0.7,0.9,,2834.31,475,162,637,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""Single variable x increases monotonically toward the bound 0.""}","analysis: |   The loop continues while `x < 0`. Inside the loop, `x` is updated to `x + y` and `y` is incremented by 1.   Since `y` increases by 1 in every iteration, the value added to `x` grows.   C"
2026-01-16T17:21:03.730788,rf_template_fewshot_Creative,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_fewshot,glm47,glm-4.7,1.0,1.0,,11357.52,475,605,1080,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""The variable x is strictly less than 0 and increases in every iteration (x = x + y, and y eventually becomes positive or is non-negative). Since x approaches the upper bound 0, -x serves as a strictly decreasing ranking function.""}","analysis: |   The loop condition is `x < 0`. The body updates `x` to `x + y` and `y` to `y + 1`.   Considering the loop invariant derived from the updates:   In iteration `k`, `y_k = y_0 + k`. The val"
2026-01-16T20:35:18.974410,rf_template_Deterministic,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template,qwenplus,qwen-plus,0.0,1.0,,26099.52,274,1008,1282,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct phases: (1) when y ≤ 0, y increases toward positivity, and (2) when y > 0, x increases with growing steps until x ≥ 0. A multi-phase ranking function captures these phases, with finite progress in each.""}",```yaml analysis: |   We analyze the loop:        while (x < 0) {           x = x + y;           y = y + 1;       }    Variables:     - x and y are variables modified in the loop.     - The loop condi
2026-01-16T20:36:07.492640,rf_template_Balanced,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template,qwenplus,qwen-plus,0.7,0.9,,48510.4,274,2048,2322,,,"{""analysis"": ""We analyze the loop:\n\n    while (x < 0) {\n        x = x + y;\n        y = y + 1;\n    }\n\nThe loop evolves both x and y. Let's examine their behavior:\n\n- y is incremented by 1 in each iteration: y → y + 1. So y increases monotonically.\n- x is updated as x = x + y. Since y increases every iteration, the increment to x grows over time.\n\nInitially, x < 0. We want to determine whether x eventually becomes ≥ 0, causing termination.\n\nConsider the sequence of updates:\n  Iteration 0: x₀ < 0, y₀ = y\n  Iteration 1: x₁ = x₀ + y₀, y₁ = y₀ + 1\n  Iteration 2: x₂ = x₁ + y₁ = x₀ + y₀ + (y₀ + 1)\n  Iteration 3: x₃ = x₂ + y₂ = x₀ + y₀ + (y₀ + 1) + (y₀ + 2)\n\nIn general, after k iterations:\n  y_k = y₀ + k\n  x_k = x₀ + Σ_{i=0}^{k-1} (y₀ + i) = x₀ + k*y₀ + (k*(k-1))/2\n\nThis is a quadratic in k: x_k = x₀ + k*y₀ + k(k-1)/2.\n\nFor large enough k, this quadratic will dominate and become positive, regardless of initial x₀ < 0, provided that y eventually grows — which it does.\n\nHowever, if y starts very negative, it may take many steps before the quadratic term causes x to escape negativity.\n\nStill, since y increases unboundedly and the increments to x grow linearly with y, x will eventually increase super-linearly and exceed 0.\n\nTermination depends on the combined effect: y increases steadily, and x receives increasingly large increments. There is no fixed phase; instead, both variables contribute monotonically toward progress, but not independently.\n\nHowever, note:\n  - y increases by 1 each time → divergent increase.\n  - x is being driven upward by an increasing amount.\n\nThe key insight: although x can initially decrease (e.g., if y is negative), eventually y becomes positive, and then x starts increasing rapidly.\n\nBut we must prove termination for all initial states where x < 0.\n\nActually, counterexample? Suppose y is very negative and x is slightly negative:\n  x = -1, y = -1000\n  Then next: x = -1 + (-1000) = -1001, y = -999\n  Then x = -1001 + (-999) = -2000, y = -998\n  So x decreases rapidly at first.\n\nBut eventually y will reach 0 and then become positive. Once y > 0 and large enough, the increments to x will overcome previous losses.\n\nHowever, does x ever recover?\n\nLet’s suppose at some point y becomes positive and continues growing. The sum added to x from step k onward behaves like a quadratic with positive leading coefficient. So yes — eventually, the cumulative sum dominates any finite initial deficit.\n\nTherefore, the loop terminates for all finite initial values.\n\nTo rank this loop, we need a measure that captures eventual progress.\n\nCan we find a ranking function?\n\nConsider using a lexicographic ranking function.\n\nIdea: when y ≤ 0, x may decrease, but y is increasing — so we can use y as a component that makes progress toward becoming positive.\n\nOnce y > 0, then x begins to increase (since x = x + y, and y > 0). But x might still be negative.\n\nAlternatively, observe that the expression:\n\n    f(x, y) = (-x, -y)   if y < 0\n    g(x, y) = -x          if y >= 0\n\ndoesn't easily compose.\n\nAnother idea: use a potential based on how far y is from making x grow.\n\nBut consider a simpler path: use the fact that y increases without bound, and once y is large enough, x will eventually become non-negative due to quadratic growth.\n\nHowever, standard linear or lexicographic ranking functions may struggle because:\n  - x can decrease initially\n  - y always increases, but not sufficient alone (doesn’t go to zero)\n\nBut note: y increases by 1 each iteration → strictly increasing integer-valued variable.\n\nAnd although x may decrease, the system state (x, y) cannot cycle because y increases forever.\n\nYet, we need bounded number of iterations.\n\nActually, from earlier:\n\n    After k iterations: x_k = x₀ + k*y₀ + k(k-1)/2\n\nWe want x_k >= 0.\n\nSolve: k²/2 + k(y₀ - 1/2) + x₀ >= 0\n\nThis is a quadratic inequality in k — has a finite smallest solution. Hence, only finitely many iterations.\n\nSo the loop terminates.\n\nNow for ranking template:\n\nWe cannot use a single linear function (like -x or -y), because:\n  - If we try r = -x: fails because x may decrease → r increases.\n  - If we try r = -y: y increases → r decreases, but not linked to x condition.\n\nHowever, notice:\n  - y increases monotonically → useful progress metric.\n  - Eventually x increases, but not from start.\n\nBut we can divide execution into two phases:\n  Phase 1: y ≤ Y₀ (some bound), during which y increases.\n  Phase 2: y > Y₀ and x is increasing.\n\nHowever, the threshold depends on parameters.\n\nAlternatively, use a lexicographic ranking function of depth 2:\n\n    R = (L1, L2)\n\nIdea:\n  While x < 0:\n    - If y ≤ 0: focus on y increasing toward 0.\n    - If y > 0: focus on x increasing.\n\nBut control doesn’t switch explicitly.\n\nBetter idea: use ( -y, -x ) as a lexicographic tuple when y ≤ 0, but then change?\n\nNot static.\n\nStandard approach: use a lexicographic ranking function that works globally.\n\nConsider ranking function:\n\n    f1 = -y\n    f2 = -x\n\nBut y increases → -y decreases → good.\nBut x may decrease → -x increases → bad.\n\nReverse order: R = (-x, -y)\n\nBut -x may increase initially.\n\nInstead, consider progress in terms of distance to termination.\n\nKnown result: loops with affine updates and guards can often be handled with lexicographic linear ranking functions (LLRFs) of small depth.\n\nTry depth-2 lexicographic function.\n\nConsider candidate: R = (c1 * y + c2 * x + c3, d1 * x + d2)\n\nBut perhaps simpler: use the fact that y increases by 1 each time — so after sufficiently many steps, y will dominate.\n\nInsight: even though x may decrease initially, the value of y serves as a phase counter.\n\nWe can use a multi-phase ranking function:\n\n  Phase 1: while y < Y*, count down y toward Y*\n  Phase 2: while y >= Y* and x < 0, count down -x\n\nBut Y* depends on initial conditions — not static.\n\nHowever, for ranking abstraction, we don’t need exact thresholds.\n\nAlternatively, use lnested with depth 2: use y as primary measure (increasing), and x as secondary (eventually increasing).\n\nBut standard lnested requires components to decrease.\n\nSo define measures that decrease.\n\nLet’s define:\n\n    m1 = M - y   // where M is some upper bound? No — y goes to infinity.\n\nCannot bound M.\n\nInstead, since y increases by 1, the quantity “how much more until y reaches 0” is finite if y₀ is finite.\n\nBut y may start positive.\n\nCase analysis:\n\n  Case 1: y >= 0 initially → then x increases by at least y ≥ 0 in each iteration. If y > 0, then x increases by at least y_min per step → linear increase → x will reach 0 in finite steps.\n\n      Then a single measure -x suffices? But if y = 0, then x stays same → infinite loop!\n\n      Wait! If y = 0 and x < 0:\n          x = x + 0 = x\n          y = 0 + 1 = 1\n      So next iteration: y = 1\n      Then x = x + 1 → now increases by 1 each time.\n\n      So if y = 0, then next y = 1, and then x increases by 1 per step → will eventually make x >= 0.\n\n      So even if y starts at 0, safe.\n\n      Only issue: could x remain < 0 forever? No, because once y > 0, x increases by at least 1 per step (actually more), so it will reach 0.\n\n      But what if y starts negative?\n\n      Example: y = -k, x = -1\n\n      Then:\n        Step 1: x = -1 - k, y = -k+1\n        Step 2: x = -1 -k + (-k+1) = -1 -2""}",```yaml analysis: |   We analyze the loop:        while (x < 0) {           x = x + y;           y = y + 1;       }    The loop evolves both x and y. Let's examine their behavior:    - y is incremente
2026-01-16T20:36:57.909392,rf_template_Creative,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template,qwenplus,qwen-plus,1.0,1.0,,50408.7,274,2048,2322,,,"{""analysis"": ""We are analyzing the loop:\n    while (x < 0) {\n        x = x + y;\n        y = y + 1;\n    }\n\nLet's examine the behavior of variables:\n\n- The loop condition is (x < 0), so the loop continues as long as x is negative.\n- In each iteration:\n    x := x + y\n    y := y + 1\n\nConsider how y evolves: it increases by 1 every iteration. So y grows linearly.\n\nNow consider x: it is updated by adding the current value of y. Since y increases over time, the amount added to x increases with each iteration — this is akin to a quadratic growth in x over time.\n\nSuppose initially: x₀ < 0, y₀ arbitrary.\n\nAfter 1st iteration:\n    x₁ = x₀ + y₀\n    y₁ = y₀ + 1\n\nAfter 2nd iteration:\n    x₂ = x₁ + y₁ = x₀ + y₀ + (y₀ + 1) = x₀ + 2y₀ + 1\n    y₂ = y₀ + 2\n\nAfter n iterations (assuming x never reached non-negative):\n    yₙ = y₀ + n\n    xₙ = x₀ + Σ_{i=0}^{n-1} (y₀ + i)\n       = x₀ + n y₀ + (0 + 1 + ... + n-1)\n       = x₀ + n y₀ + n(n-1)/2\n\nThis is a quadratic in n: xₙ ≈ (1/2)n² + (y₀ - 1/2)n + x₀\n\nSince the leading coefficient is positive, xₙ will eventually become positive, so the loop terminates for any initial values (though we only care about cases where initial x < 0).\n\nFor ranking function: we need a measure that decreases (or increases) monotonically and bounds termination.\n\nNote: x is not necessarily increasing if y is negative — but eventually y will grow large enough (due to incrementing by 1) so that even if initially negative, y will become non-negative and then positive. Once y > 0, then subsequent additions to x will be positive or growing, so x will increase faster.\n\nHowever, despite complex dynamics, the expression for xₙ shows it becomes positive in finite time, so termination is guaranteed.\n\nBut can we find a lexicographic ranking function?\n\nIdea: since y increases by 1 each time (definitely strictly increasing), and once y is large enough, x will start increasing quadratically, perhaps we can use y as part of a multi-phase behavior?\n\nAlternatively, observe:\n- y increases without bound (monotonic progress).\n- Even if x dips lower initially (e.g., if y is very negative), eventually y becomes positive and then x starts increasing, and rapidly so.\n\nBut during early phases, x could decrease initially? Let’s test:\n\n    Suppose x = -10, y = -5 → x < 0, enter loop\n    x = -10 + (-5) = -15\n    y = -4\n\n    Next: x = -15 + (-4) = -19, y = -3\n    Continue... x decreasing, y increasing slowly.\n\n    But eventually y reaches 0, then positive.\n\n    When y = k > 0, and growing, the increments to x become positive and larger.\n\nSo there may be a phase where x is decreasing, followed by increasing.\n\nTherefore, x alone cannot be a component in a simple decreasing/increasing ranking.\n\nHowever, note that y is strictly increasing: y → y+1 per step. So y acts as a counter.\n\nAlso, the number of iterations is bounded (because x eventually becomes ≥0). So a single-variable ranking based on some function of x and y that maps into a well-founded domain would suffice.\n\nCan we define a ranking function f(x, y) that decreases each iteration and is bounded below?\n\nTry to find f such that f(x, y) > f(x+y, y+1) whenever x < 0.\n\nConsider energy-like functions. Given that eventual growth is quadratic, perhaps try something involving negative x and dependence on y.\n\nAlternative idea: since y increases, and eventually dominates, use a lexicographic tuple where one component handles the \""negative y\"" phase and another the \""positive progress\"" phase.\n\nHowever, observe: y increases steadily — this gives us monotonic progress. Also, from the closed form, the execution length is finite.\n\nBut x may go through non-monotonic phases. Therefore, using a single measure like “distance to zero” for x won’t work.\n\nInstead, consider combining both variables.\n\nLet us consider a lexicographic ranking function of depth 2.\n\nPossibility:\n  R = (r₁, r₂)\n\nIdea:\n  Phase 1: y ≤ 0 → we are not making progress on x yet; want to bound how long this phase lasts.\n  But note: y increases by 1 each time → the number of iterations until y > 0 is at most |y₀| + 1 — bounded.\n\n  Phase 2: y > 0 → now x starts receiving positive additions, and they grow.\n\nBut even better: since y increases strictly, we can use -y as a measure when y is negative: it decreases (since y increases), so -y goes down.\n\nHowever, standard ranking functions require decrease in all components.\n\nLet’s try **lexicographic**:\n\n  Let:\n      c₁ = y   → increases indefinitely → no upper bound → can't use directly as decreasing.\n\nInstead, think backwards: what quantity reduces?\n\nActually, we can reframe: instead of measuring current state, estimate \""iterations remaining\"".\n\nBut SVMRanker works with templates.\n\nStandard approach in lexicographic settings: use components that decrease in stages.\n\nInsight: although x may decrease initially, the pair (x, y) evolves such that the system cannot cycle (due to y strictly increasing), and x will eventually increase due to quadratic accumulation.\n\nBecause y increases by 1 each iteration (discrete), and integer-valued (assumed), then after at most k = max(0, floor(-y₀)+1) steps, y becomes non-negative.\n\nThen once y ≥ 0, every subsequent iteration adds at least a fixed minimum to x? Not quite — if y just turns 0, adds 0; next adds 1, then 2, etc.\n\nBut once y ≥ 0, the increments to x are non-decreasing.\n\nMoreover, the sum of increments from step k onward behaves quadratically.\n\nBut for ranking, we don’t need exact count — just a function that decreases and hits zero.\n\nAnother idea: use an abstract measure based on potential number of steps until x ≥ 0.\n\nDue to complexity of interplay, simpler idea: since y increases by 1 always, use y as a component in a multi-phase ranking?\n\nWait: **lmulti** is for distinct phases — e.g., first phase while y < 0, second while x < 0 and y ≥ 0.\n\nBut in both phases the same statements execute.\n\nHowever, different behaviors.\n\nCould we apply two separate rankings?\n\nIn Phase 1: y < Y0 (increasing), but x may drop → but phase ends in finite steps (≤ -y₀ steps) → so number of steps here bounded.\n\nBut loop must terminate overall.\n\nHowever, SVMRanker lmulti with depth 2 might model:\n    Phase 1: while y ≤ 0, rank with one function (e.g. -y, which decreases)\n    Phase 2: while y > 0 and x < 0, use a different ranking (e.g. some upper bound on remaining steps, like a quadratic bound)\n\nBut estimating required function forms is hard.\n\nSimpler: because y increases by 1 unconditionally, the entire sequence has no infinite repetition — y goes to infinity, so control can't loop infinitely unless x stays < 0 forever, which it can't due to quadratic drift upward.\n\nSo actually, a single ranking function may suffice — but nonlinear.\n\nHowever, the question asks for simplest ranking *template* among lnested and lmulti.\n\nLet's reconsider lexicographic.\n\nCan we build a lexicographic ranking tuple?\n\nTry:\n    Component 1: sign-related, e.g., whether y < 0\n    Component 2: residual toward termination\n\nBut signs change only once.\n\nBetter: consider the tuple:\n    r₁ = -y     [decreases when y increases, only while y < 0]\n    but when y > 0, -y starts increasing — bad.\n\nTry instead:\n    Use (c1, c2) where:\n      c1 = 0 if y > 0, else (some decreasing)\n      c2 = something related to x\n\nBut complicated.\n\nAlternate insight: since y increases by 1 each time, the transformation is deterministic and divergent in y.\n\nAnd x undergoes cumulative addition of a linearly increasing sequence.\n\nThe minimal number of iterations until termination is bounded, but depends on initial values.\n\nHowever, because the system has only one path and affine updates, it is known that such loops admit ranking functions of the form f(x,y) = α x + β y + γ, or possibly quadratic.\n\nBut suppose we attempt a linear ranking function: f(x, y) = a*x + b*y + c\n\nWe require:""}","```yaml analysis: |   We are analyzing the loop:       while (x < 0) {           x = x + y;           y = y + 1;       }    Let's examine the behavior of variables:    - The loop condition is (x < 0),"
2026-01-16T20:36:59.816476,rf_template_autoverus_seahorn_v1_Deterministic,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.0,1.0,,1905.76,237,19,256,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","```yaml configuration:   type: ""lnested""   depth: 1 ```"
2026-01-16T20:37:01.792746,rf_template_autoverus_seahorn_v1_Balanced,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.7,0.9,,1975.27,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:37:02.965434,rf_template_autoverus_seahorn_v1_Creative,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,1.0,1.0,,1171.73,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:37:30.458296,rf_template_fewshot_Deterministic,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_fewshot,qwenplus,qwen-plus,0.0,1.0,,27487.76,485,1144,1629,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two distinct phases: first y increases to become positive (counted down via -y), then x increases to reach 0 (counted down via -x). Each phase has its own decreasing component.""}","```yaml analysis: |   The loop condition is (x < 0), so termination requires x to eventually become >= 0.   In each iteration:     - x is updated to x + y     - y is incremented by 1   The value of x "
2026-01-16T20:38:15.114615,rf_template_fewshot_Balanced,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_fewshot,qwenplus,qwen-plus,0.7,0.9,,44650.22,485,1962,2447,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first y increases to become positive (bounded steps), then x increases super-linearly to become non-negative.""}","```yaml analysis: |   The loop condition is (x < 0), so termination requires x to eventually become >= 0.   In each iteration:     - x is updated as x = x + y     - y is updated as y = y + 1    We ana"
2026-01-16T20:38:26.188234,rf_template_fewshot_Creative,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_fewshot,qwenplus,qwen-plus,1.0,1.0,,11071.07,485,424,909,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases based on sign of y: when y ≤ 0 and y > 0. After y becomes positive, x increases with growing steps, ensuring eventual termination.""}","```yaml analysis: |   The loop condition is (x < 0), so termination requires x to eventually become >= 0.   In each iteration:     - x is updated as x = x + y     - y is updated as y = y + 1    We ana"
2026-01-17T01:54:37.817932,rf_template_Deterministic,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template,qwenmax,qwen3-max,0.0,1.0,,65620.87,274,2982,3256,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop has two phases: initially y may be non-positive, during which y increases (so -y decreases); once y becomes positive, x increases (so -x decreases). A multi-phase ranking function with depth 2 captures this behavior.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y is incremented by 1 each iteration: y := y + 1.    Observe that y increases monotonically. Howev"
2026-01-17T01:55:32.675679,rf_template_Balanced,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template,qwenmax,qwen3-max,0.7,0.9,,54850.91,274,1701,1975,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop has two phases: (1) while y < 0, y increases toward 0; (2) once y ≥ 0, x increases toward ≥ 0. A multi-phase ranking function with depth 2 captures these two stages of progress.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y is incremented by 1 each iteration: y := y + 1.    We need to determine whether this loop termin"
2026-01-17T01:55:49.464233,rf_template_Creative,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template,qwenmax,qwen3-max,1.0,1.0,,16785.5,274,453,727,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two phases: first, y increases until it becomes positive; second, x increases (toward non-negative) ensuring termination. A multi-phase ranking function with depth 2 captures this behavior.""}","```yaml analysis: |   The loop condition is (x < 0), so the loop continues while x is negative.   In each iteration:     x := x + y     y := y + 1    Observe that y increases by 1 every iteration, so "
2026-01-17T01:55:51.627205,rf_template_autoverus_seahorn_v1_Deterministic,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.0,1.0,,2161.94,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:55:53.060212,rf_template_autoverus_seahorn_v1_Balanced,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.7,0.9,,1432.07,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:55:54.831875,rf_template_autoverus_seahorn_v1_Creative,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,1.0,1.0,,1770.73,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:56:24.423703,rf_template_fewshot_Deterministic,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_fewshot,qwenmax,qwen3-max,0.0,1.0,,29587.75,485,921,1406,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: (1) y increases until positive (x may not decrease monotonically), (2) x increases to reach non-negative. Each phase has its own decreasing measure.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y := y + 1.   Since y increases by 1 each iteration, it eventually becomes positive and keeps grow"
2026-01-17T01:56:41.682381,rf_template_fewshot_Balanced,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_fewshot,qwenmax,qwen3-max,0.7,0.9,,17255.78,485,530,1015,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first y increases until positive, then x increases to exit loop.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y := y + 1.   Since y increases by 1 each iteration, it is unbounded above. However, for the loop "
2026-01-17T01:56:53.973912,rf_template_fewshot_Creative,85_pmt_yamlv2_extract.yml,loop_invariants/code2inv/85.c,,1,rf_template_fewshot,qwenmax,qwen3-max,1.0,1.0,,12289.16,485,344,829,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first y increases to become positive, then x increases to become non-negative.""}","```yaml analysis: |   The loop condition is (x < 0), so the loop continues while x is negative.   In each iteration:     x := x + y     y := y + 1    Since y increases by 1 every iteration, it grows u"
