timestamp,experiment_name,target_file,source_path,source_file,loop_id,prompt_version,config_tag,model,temperature,top_p,max_tokens,latency_ms,prompt_tokens,completion_tokens,total_tokens,template_type,template_depth,parsed_configuration,raw_response_snippet
2026-01-16T16:57:46.146717,rf_template_Deterministic,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template,glm47,glm-4.7,0.0,1.0,,7291.83,301,336,637,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The variable c increases in one branch and is reset to a lower value in another. These opposing trends require distinct phases, modeled by a multi-phase ranking function with depth 2.""}",analysis: |   The loop controls the variable `c` based on two boolean conditions controlled by `unknown()`.   There are two strictly guarded paths modifying `c`:   1. If the first condition is true an
2026-01-16T16:57:56.850031,rf_template_Balanced,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template,glm47,glm-4.7,0.7,0.9,,10700.42,301,482,783,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The variable `c` increases in one branch and decreases in another, preventing a single monotonic ranking function. A multi-phase ranking function with depth 2 is needed to handle the counting phase (increasing `c`) and the reset phase (decreasing `c`) separately.""}","analysis: |   The loop involves a variable `c` and a constant `n`.   The control flow has two main branches based on `unknown()`:   1.  Branch A: If true, `c` is incremented (`c = c + 1`) provided `c "
2026-01-16T16:58:04.878282,rf_template_Creative,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template,glm47,glm-4.7,1.0,1.0,,8025.02,301,440,741,lmulti,1,"{""type"": ""lmulti"", ""depth"": 1, ""explanation"": ""The variable c increases in one branch and resets in another, forming a cyclic pattern. This requires a multi-phase ranking (depth 1) to handle the non-monotonic change in the metric (n - c).""}","analysis: |   The loop modifies variable `c` within the range $[1, n]$.   There are two specific behaviors:   1. When the first `unknown()` is true, `c` is incremented (if $c \neq n$), i.e., $c \lefta"
2026-01-16T16:58:06.711994,rf_template_autoverus_seahorn_v1_Deterministic,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.0,1.0,,1832.74,264,14,278,lmulti,1,"{""type"": ""lmulti"", ""depth"": 1}","configuration:   type: ""lmulti""   depth: 1"
2026-01-16T16:58:07.746025,rf_template_autoverus_seahorn_v1_Balanced,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.7,0.9,,1033.09,264,14,278,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T16:58:08.841157,rf_template_autoverus_seahorn_v1_Creative,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,1.0,1.0,,1094.17,264,14,278,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T16:58:14.515055,rf_template_fewshot_Deterministic,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_fewshot,glm47,glm-4.7,0.0,1.0,,5671.72,509,269,778,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Variable c increases in one phase and resets (decreases) in another; distinct phases of progress are required.""}","```yaml analysis: |   The variable c behaves like a bounded counter. In the first branch, it increments linearly towards an upper bound n (monotone progress). In the second branch, it resets to 1, whi"
2026-01-16T16:58:18.916135,rf_template_fewshot_Balanced,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_fewshot,glm47,glm-4.7,0.7,0.9,,4399.36,509,260,769,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits cyclic behavior where c increases and resets; this requires 2 phases to model the progress toward the bound and the reset event.""}","analysis: |   The variable `c` oscillates between two behaviors: it increments until it reaches `n`, then resets to 1. This is a cyclic behavior where `c` does not strictly decrease in a linear fashio"
2026-01-16T16:58:22.334550,rf_template_fewshot_Creative,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_fewshot,glm47,glm-4.7,1.0,1.0,,3416.63,509,181,690,lnested,2,"{""type"": ""lnested"", ""depth"": 2, ""explanation"": ""Variable increases in one phase and resets in another; need 2 arguments (e.g., reset count, value) to argue termination.""}","analysis: |   The loop counter `c` is modified in two branches. In one branch, `c` increments (up to a bound `n`). In the other branch, `c` resets to `1` (which is smaller than `n`, assuming `n > 1`)."
2026-01-16T20:00:15.634529,rf_template_Deterministic,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template,qwenplus,qwen-plus,0.0,1.0,,50011.18,308,2048,2356,,,"{""analysis"": ""The loop modifies the variable `c` in two distinct branches, depending on the value of `c` relative to `n` and an unknown condition.\n\n- In one branch: if `c != n`, then `c` is incremented: `c = c + 1`.\n- In the other branch: if `c == n`, then `c` is reset to 1.\n\nThis behavior suggests a cyclic counter that counts from 1 up to `n`, then resets. The control flow depends on an unknown condition, but the structural evolution of `c` follows a bounded pattern: it increases until it reaches `n`, at which point it resets.\n\nSince `c` does not decrease monotonically overall, but instead increases and then resets, a single simple ranking function (e.g., `n - c`) decreases over each increment and \""resets\"" when `c` becomes 1 again. However, the reset introduces non-monotonicity in a linear measure.\n\nBut observe: each time `c` is reset, it must have previously reached `n`. The pair `(phase, c)` where phase alternates between counting and resetting, can be captured lexicographically. However, no unbounded variable grows or decreases — `c` is bounded between 1 and `n`.\n\nActually, since `n` is assumed constant (no evidence of modification), the state space for `c` is finite: values from 1 to `n`. Therefore, the loop can execute only finitely many times unless it oscillates within this finite domain.\n\nHowever, termination cannot be guaranteed unless we assume that the unknown conditions do not force infinite cycling. But for ranking function synthesis, we assume that the loop *does* terminate and seek a ranking argument.\n\nEven under nondeterminism, if the loop runs infinitely, `c` would revisit states infinitely often. But a lexicographic ranking can still be built using the control structure.\n\nConsider:\n  - When `c < n`: the path through `c++` makes progress toward `c == n`.\n  - When `c == n`: the path through reset sets `c = 1`, which could be seen as entering a new phase.\n\nBut note: after reset, `c` starts increasing again. So the full behavior is potentially infinite unless controlled by external unknown().\n\nHowever, the problem asks for a ranking template assuming termination — we are to find a ranking function structure that could prove termination if sufficient side conditions held.\n\nThe key insight: the value of `c` cycles modulo `n`. But if we consider a lexicographic tuple that tracks:\n  - A phase indicator: whether we are in an \""incrementing\"" or \""resetting\"" mode,\n  - And within incrementing, use `n - c` as a measure,\n\nBut no monotone global decrease is evident.\n\nAlternatively, consider that every time `c` reaches `n` and resets, that event could be counted. But nothing ensures this happens only finitely often.\n\nActually, the simplest way to model this is to recognize that the control has two modes:\n  Mode 1: `c < n` → only increment possible.\n  Mode 2: `c == n` → may reset to 1.\n\nBut after reset, the process repeats.\n\nHowever, suppose we consider the pair:\n  (number of completed cycles, c)\n\nBut cycle count isn't tracked.\n\nInstead, think of the state:\n\n  We can define a ranking function based on distance to reset:\n    If we view each full cycle (from 1 to n) as an abstract step, then each execution path that goes from `c = n` to `c = 1` could be considered a phase boundary.\n\nBut due to nondeterministic guards, we cannot rely on fixed phase transitions.\n\nAnother idea: use a lexicographic ranking of depth 2:\n  - First component: whether `c == n` (then reset is enabled)\n  - Second component: `n - c` (progress toward `n`)\n\nBut when `c == n`, and reset happens, `c` jumps to 1, so `n - c` jumps to `n - 1` — not decreasing.\n\nAlternatively, reverse perspective:\n  Let’s try to build a measure that decreases lexicographically.\n\nSuppose we define:\n  f = (if c == n then 0 else 1, n - c)\n\nBut not helpful.\n\nBetter: consider the following observation — the only way to leave the \""high\"" value of `c` is to reset, which can happen only once per reach of `n`. But without a growing bound, hard to rank.\n\nActually, given the finite range of `c`, the entire state space is finite if `n` is constant. Thus, **any** terminating run must eventually repeat a state. But termination requires absence of infinite executions — so unless additional constraints are imposed, the loop may not terminate.\n\nHowever, for ranking function synthesis, we look for a well-founded measure that decreases with each iteration.\n\nThe crucial point: even though `c` resets, the pattern of control could allow us to use a **multi-phase** ranking, where:\n  - Phase 1: `c` increases from 1 to `n`\n  - Phase 2: `c` resets to 1, possibly counted as a transition\n\nBut nothing bounds the number of resets.\n\nWait — unless `n` is positive and fixed, and `c` always progresses deterministically upward when not at `n`, then the number of steps between resets is at least `n - 1`. But still, number of resets could be infinite.\n\nConclusion: there is no global ranking function unless we assume that the number of resets is limited — but the code shows no such limit.\n\nBut perhaps the intended behavior is a counter mod n? Then it doesn't terminate — but the task assumes we are to find a ranking template for termination.\n\nRe-read: we are to choose the **simplest ranking template** that could work **if** the loop terminates.\n\nGiven that `c` evolves in a bounded domain and changes in a deterministic way except for control via `unknown()`, the only way to get a ranking is to exploit progress across resets.\n\nHowever, note: each reset happens only once per reaching `c = n`. And between resets, `c` must increase at least `n - 1` times (from 1 to n). But still not enough.\n\nAlternative idea: use a **lexicographic** ranking of depth 2:\n\n  f = (c >= n ? 1 : 0,  // phase flag: about to reset?\n       ...)\n\nNot promising.\n\nInsight: consider the trace of control. There are two kinds of transitions:\n  T1: c := c+1  (only possible when c ≠ n)\n  T2: c := 1   (only possible when c = n)\n\nSuppose we associate ranks:\n\n  For T1: progress measured by `n - c`, which decreases by 1.\n  For T2: `c` drops from `n` to `1`, so `n - c` increases — bad.\n\nBut if we consider a measure like:\n\n  r = (cycle_count, local_step)\n\nwhere `cycle_count` increases on each reset, but we want decrease, so instead reverse.\n\nNo.\n\nBetter: use a **multi-phase** approach where:\n  - One phase corresponds to the current \""epoch\"" starting after a reset.\n  - But again, epoch count increases — not helpful for ranking.\n\nReverse the logic: suppose we use a ranking that combines a reset counter in reverse order? Not grounded.\n\nAnother standard technique: for round-robin or cyclic counters, **lexicographic ranking functions** of depth 2 can be used, e.g., `(b, d)` where:\n  - b = 0 if c < n, and b = 1 if c == n\n  - d = n - c\n\nBut when c < n: b = 0, d decreases with each increment → good.\nWhen c == n: b = 1, d = 0.\n  Then either:\n    - c stays at n? no — next step might reset: c becomes 1 → now b = 0, d = n - 1.\n\n  Now compare (1, 0) vs (0, n-1): if we use lex-order, (1,0) > (0,n-1) only if our order expects first component to dominate.\n\n  But (1,0) > (0, anything) — yes, in usual lex order.\n\n  So the reset transition causes a drop from (1,0) to (0, n-1) — which is a strict decrease in the first component.\n\n  Then while in b=0, d decreases.\n\n  So overall: the pair (b, d) decreases lexicographically in every iteration?\n\n  Let's check:\n    Case 1: c < n → c becomes c+1.\n      Before: (0, n - c)\n      After: (0, n - (c+1)) = (0, n - c - 1) → second component decreases → lex decrease.\n\n    Case 2: c == n and reset happens → c becomes 1.\n      Before: (1, 0)  [since c==n → b=1; d = n - n = 0]\n      After: c = 1 → if n > 1, then 1 < n → b=0, d = n - 1 → (0, n-1)\n      Compare (1,0) and (0,n-1""}","```yaml analysis: |   The loop modifies the variable `c` in two distinct branches, depending on the value of `c` relative to `n` and an unknown condition.    - In one branch: if `c != n`, then `c` is "
2026-01-16T20:00:47.400785,rf_template_Balanced,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template,qwenplus,qwen-plus,0.7,0.9,,31760.75,308,1250,1558,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""A single piecewise-defined ranking function exists that strictly decreases in each iteration, based on the value of c relative to n. When c < n, it increases toward n, decreasing (n - c); when c == n, it resets to 1, causing a drop from ranking value n to n - 1. Thus, a lexicographic tuple of depth 1 suffices.""}","```yaml analysis: |   The loop modifies the variable `c` in two distinct branches, depending on the value of `c` relative to `n` and some unknown conditions.    - In one branch: if `c != n`, then `c` "
2026-01-16T20:01:11.659111,rf_template_Creative,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template,qwenplus,qwen-plus,1.0,1.0,,24253.88,308,902,1210,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct behavioral phases: incrementing c toward n and resetting c to 1 when c == n. A multi-phase ranking function with depth 2 captures these alternating modes of operation.""}","```yaml analysis: |   The loop involves a variable `c` that is updated in two distinct cases based on conditions involving `c` and `n`.     - In one branch, if `c != n`, then `c` is incremented by 1. "
2026-01-16T20:01:12.783637,rf_template_autoverus_seahorn_v1_Deterministic,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.0,1.0,,1123.52,271,14,285,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:01:13.853584,rf_template_autoverus_seahorn_v1_Balanced,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.7,0.9,,1068.8,271,14,285,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:01:14.943437,rf_template_autoverus_seahorn_v1_Creative,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,1.0,1.0,,1088.86,271,14,285,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:01:38.771215,rf_template_fewshot_Deterministic,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_fewshot,qwenplus,qwen-plus,0.0,1.0,,23821.9,519,1305,1824,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two behavioral modes detected: incrementing c toward n, and resetting c to 1 when equal to n. No monotonic descent observed, but phase distinction captures structural alternation. Assumes potential for multi-phase modeling despite lack of proven descent.""}","```yaml analysis: |   The loop updates variable `c` in two different branches:   - With some condition, if `c != n`, then `c` is incremented: `c = c + 1`.   - Otherwise, when `c == n`, `c` is reset to"
2026-01-16T20:02:00.060229,rf_template_fewshot_Balanced,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_fewshot,qwenplus,qwen-plus,0.7,0.9,,21284.41,519,797,1316,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""No clear progress metric; optimistic fallback to single-component lexicographic ranking due to lack of phase separation evidence.""}","```yaml analysis: |   The loop updates variable `c` in a non-deterministic way based on unknown conditions.    In one branch, if `c != n`, then `c` is incremented by 1.    In another branch, if `c == "
2026-01-16T20:02:30.884876,rf_template_fewshot_Creative,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_fewshot,qwenplus,qwen-plus,1.0,1.0,,30819.88,519,945,1464,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Loop exhibits two behavioral modes: one where c increases toward n, and another where it resets sharply to 1; this supports a multi-phase ranking interpretation.""}","```yaml analysis: |   The loop updates variable `c` in two different branches:   - With some condition, if `c != n`, then `c` is incremented: `c = c + 1`.   - Otherwise, if `c == n`, then `c` is reset"
2026-01-17T01:00:48.752569,rf_template_Deterministic,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template,qwenmax,qwen3-max,0.0,1.0,,56150.57,308,1441,1749,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct phases: (1) incrementing c towards n, and (2) resetting c to 1 when c == n. A multi-phase ranking function with depth 2 can model these phases, using n - c as a local ranking function in the first phase.""}","```yaml analysis: |   The loop body conditionally updates variable `c` in two branches:      - In the ""then"" branch (when unknown() is true), if `c != n`, then `c` is incremented by 1.   - In the ""els"
2026-01-17T01:01:59.099113,rf_template_Balanced,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template,qwenmax,qwen3-max,0.7,0.9,,70339.9,308,1994,2302,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits phase-wise behavior: c increases from 1 to n (phase 1), then may reset to 1 (transition to phase 2, which restarts phase 1). Multi-phase ranking with depth 2 captures this cyclic progress.""}","```yaml analysis: |   The loop body contains conditional updates to variable `c`:     - In the first branch (when unknown() is true and c != n), `c` is incremented by 1.     - In the second branch (wh"
2026-01-17T01:03:35.311001,rf_template_Creative,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template,qwenmax,qwen3-max,1.0,1.0,,96201.13,308,2846,3154,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two phases: (1) incrementing c towards n, where n - c decreases, and (2) resetting c to 1 when c == n. A multi-phase ranking function with depth 2 can model progress in each phase, assuming resets occur only finitely often.""}",```yaml analysis: |   The loop body conditionally updates variable `c` based on unknown conditions and comparisons with `n`. There are two branches:      1. If the first unknown condition is true and 
2026-01-17T01:03:36.671462,rf_template_autoverus_seahorn_v1_Deterministic,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.0,1.0,,1359.19,271,14,285,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:03:38.286858,rf_template_autoverus_seahorn_v1_Balanced,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.7,0.9,,1614.59,271,14,285,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:03:40.018974,rf_template_autoverus_seahorn_v1_Creative,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,1.0,1.0,,1731.21,271,14,285,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:04:51.774162,rf_template_fewshot_Deterministic,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_fewshot,qwenmax,qwen3-max,0.0,1.0,,71747.24,519,1919,2438,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""Primary progress is c increasing toward n; ranking function n - c decreases in the main branch. Reset branch may not occur in terminating executions.""}","```yaml analysis: |   The loop body has two branches:     - In the first branch (when unknown() is true), if c != n, then c is incremented by 1.     - In the second branch (when unknown() is false), i"
2026-01-17T01:05:47.852010,rf_template_fewshot_Balanced,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_fewshot,qwenmax,qwen3-max,0.7,0.9,,56071.42,519,1204,1723,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Loop has two modes: c incrementing toward n, and c resetting to 1; reset likely triggers progress in an implicit measure, requiring multi-phase ranking.""}","```yaml analysis: |   The loop body conditionally either increments c (if c != n) or resets c to 1 (if c == n).   This suggests c cycles in the range [1, n]: it increases until it reaches n, then wrap"
2026-01-17T01:07:18.174160,rf_template_fewshot_Creative,58_pmt_yamlv2_extract.yml,loop_invariants/code2inv/58.c,,1,rf_template_fewshot,qwenmax,qwen3-max,1.0,1.0,,90310.93,519,2883,3402,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: (1) c increases toward n, (2) c resets to 1 when c == n. Although no explicit variable decreases across phases, the phase structure matches multi-phase templates.""}","```yaml analysis: |   The loop body conditionally updates variable c based on unknown conditions and comparisons with n.   When c != n, c is incremented (c = c + 1). When c == n, c is reset to 1.   Th"
