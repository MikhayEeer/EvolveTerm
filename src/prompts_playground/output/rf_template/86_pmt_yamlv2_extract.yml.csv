timestamp,experiment_name,target_file,source_path,source_file,loop_id,prompt_version,config_tag,model,temperature,top_p,max_tokens,latency_ms,prompt_tokens,completion_tokens,total_tokens,template_type,template_depth,parsed_configuration,raw_response_snippet
2026-01-16T17:21:21.907644,rf_template_Deterministic,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template,glm47,glm-4.7,0.0,1.0,,18170.49,267,820,1087,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits multi-phase behavior because 'x' is not monotonic with respect to the loop condition. When 'y' is negative, 'x' decreases (moving away from termination), while 'y' increases. Once 'y' becomes non-negative, 'x' increases towards the exit condition. This requires two phases: one where 'y' increases (or -y decreases) and another where 'x' approaches 0.""}",analysis: |   The loop condition is `x < 0`. The body updates variables as `x' = x + y` and `y' = y + 1`.      Let the initial values be $x_0$ and $y_0$.   The update for $y$ is strictly increasing: $
2026-01-16T17:21:49.249864,rf_template_Balanced,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template,glm47,glm-4.7,0.7,0.9,,27334.85,267,2017,2284,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct phases. In the first phase, variable y increases (which may cause x to decrease). Once y becomes positive, the second phase begins where x increases monotonically until the loop condition x < 0 becomes false.""}",analysis: |   The loop condition is `x < 0`. The loop body updates variables as follows:   `x = x + y` and `y = y + 1`.    Let's analyze the behavior of `x`:   - `x` is updated by adding the current v
2026-01-16T17:21:57.945129,rf_template_Creative,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template,glm47,glm-4.7,1.0,1.0,,8692.56,267,480,747,lnested,2,"{""type"": ""lnested"", ""depth"": 2, ""explanation"": ""The variable y increases strictly every iteration. By ranking with (-y, x), we establish a lexicographic decrease primarily driven by -y. Depth 2 is needed to handle the potential increase of x while y is negative.""}",analysis: |   The loop condition is `x < 0`. We need to analyze how the variables `x` and `y` change to show termination.   Let $\Delta x = (x + y) - x = y$.   Let $\Delta y = (y + 1) - y = 1$.   Sinc
2026-01-16T17:21:59.020535,rf_template_autoverus_seahorn_v1_Deterministic,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.0,1.0,,1074.4,230,14,244,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T17:22:00.094728,rf_template_autoverus_seahorn_v1_Balanced,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.7,0.9,,1073.41,230,14,244,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2}","configuration:   type: ""lmulti""   depth: 2"
2026-01-16T17:22:01.117569,rf_template_autoverus_seahorn_v1_Creative,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,1.0,1.0,,1021.92,230,14,244,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2}","configuration:   type: ""lmulti""   depth: 2"
2026-01-16T17:22:05.618336,rf_template_fewshot_Deterministic,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_fewshot,glm47,glm-4.7,0.0,1.0,,4499.01,475,192,667,lnested,2,"{""type"": ""lnested"", ""depth"": 2, ""explanation"": ""Variables decrease in dependent order: y must bound x's rate.""}","analysis: |   The loop condition depends solely on `x`. The update rule increments `y` on every iteration and adds the original value of `y` to `x` ($x' = x + y$). Since `y` increases, the magnitude a"
2026-01-16T17:22:08.589823,rf_template_fewshot_Balanced,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_fewshot,glm47,glm-4.7,0.7,0.9,,2970.71,475,151,626,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""Single variable x increases strictly toward bound 0.""}","analysis: |   The loop condition depends only on `x < 0`.   Inside the loop, `y` strictly increases (`y = y + 1`).   Since `x` is updated by `x = x + y`, and `y` is positive (initially) and increasing"
2026-01-16T17:22:12.011213,rf_template_fewshot_Creative,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_fewshot,glm47,glm-4.7,1.0,1.0,,3419.81,475,191,666,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""Single variable x increases monotonically towards bound 0.""}","analysis: |   The loop condition depends solely on x (< 0). Inside the loop, y is incremented by 1 (y + 1), and x becomes x + previous_y (which is effectively x + y_before).   Let $\Delta\_x = y - 1$ "
2026-01-16T20:39:12.900509,rf_template_Deterministic,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template,qwenplus,qwen-plus,0.0,1.0,,46703.55,274,2048,2322,,,"{""analysis"": ""We are analyzing the loop:\n    while (x < 0) {\n        x = x + y;\n        y = y + 1;\n    }\n\nVariables: x, y\nGuard condition: x < 0\n\nWe need to determine whether this loop terminates and find a ranking function.\n\nObservations:\n- The loop continues as long as x < 0.\n- In each iteration:\n    x_new = x + y\n    y_new = y + 1\n\nSo y increases by 1 every iteration → y is monotonically increasing.\nThe update to x depends on the current value of y.\n\nLet’s consider how x evolves:\nSuppose initial values are x₀, y₀.\nIteration 1:\n    x₁ = x₀ + y₀\n    y₁ = y₀ + 1\nIteration 2:\n    x₂ = x₁ + y₁ = x₀ + y₀ + (y₀ + 1) = x₀ + 2y₀ + 1\n    y₂ = y₀ + 2\nIteration 3:\n    x₃ = x₂ + y₂ = x₀ + 2y₀ + 1 + y₀ + 2 = x₀ + 3y₀ + 3\nIteration n:\n    We can derive:\n      yₙ = y₀ + n\n      xₙ = x₀ + Σ_{i=0}^{n-1} (y₀ + i) = x₀ + n*y₀ + n(n-1)/2\n\nSo xₙ = x₀ + n*y₀ + n(n-1)/2\n\nThis is a quadratic in n: xₙ ≈ (1/2)n² + (y₀ - 1/2)n + x₀\n\nSince the coefficient of n² is positive (1/2), xₙ → ∞ as n increases.\n\nTherefore, even if x starts negative, eventually x will become positive (unless it's already), so the loop will terminate.\n\nHowever, we need a ranking function that decreases lexicographically with each iteration.\n\nConsider candidate ranking functions.\n\nOption: Use a lexicographic ranking function.\n\nNote:\n- y increases without bound → not directly usable as a measure.\n- But the term involving y contributes positively to x over time.\n\nSince x eventually increases to positive values, we might consider x itself — but x may initially decrease if y is negative.\n\nCritical point: What if y is negative or zero initially?\n\nSuppose y₀ ≤ 0:\n  - Then in early iterations, y is non-positive, so x increases slowly or even decreases.\n  - But y increases by 1 each time, so after |y₀| + 1 steps, y becomes positive.\n  - Once y > 0, then each increment adds a positive amount to x.\n  - Eventually, cumulative effect makes x grow quadratically.\n\nSo regardless of initial y, y becomes positive in finite steps, and then x increases unboundedly.\n\nHence, the loop always terminates for any finite initial values.\n\nNow for ranking function:\n\nIdea: Use a lexicographic tuple where one component tracks whether y ≤ 0, and another tracks progress toward making x ≥ 0.\n\nBut simpler: use the value of -x when y > 0. But y may start ≤ 0.\n\nAlternatively, observe two phases:\n  Phase 1: y ≤ 0 — during this phase, y increases toward 1. This phase lasts at most |y₀| + 1 steps.\n  Phase 2: y > 0 — then x increases by at least 1, 2, 3, ..., so x grows superlinearly.\n\nSo we can define a multi-phase ranking:\n\n  Phase 1: while y ≤ 0 → rank = (-y) [decreasing as y increases]\n  Phase 2: while y > 0 and x < 0 → rank = some function of x and y that decreases\n\nBut in Phase 2, x is increasing (since y > 0), so -x is decreasing. But we want a ranking that decreases.\n\nActually, we can use a lexicographic ranking that combines both behaviors.\n\nBetter idea: since termination is guaranteed by eventual growth of x, and this growth is driven by y becoming positive, we can use:\n\n  R = (r1, r2)\n\nwhere:\n  r1 = 0 if y > 0, else 1   → ensures that once y > 0, we move to second phase\n  r2 = -x when y > 0\n\nBut we need strict decrease.\n\nConsider:\n\n  If y ≤ 0: primary component is (1, -y) → as y increases, -y decreases, so (1, -y) decreases lexicographically.\n  When y > 0: component becomes (0, -x). Since x increases by y (which is now > 0), x increases → -x decreases.\n\nHowever, transition: when y goes from 0 to 1, we go from (1, 0) to (0, -x₁). But x could have decreased overall? Not necessarily.\n\nExample: x = -5, y = -1\n    Step 1: x = -5 + (-1) = -6; y = 0 → still in r1=1, r2=0? Wait, y=0 → still y≤0 → r1=1, r2=0\n    Step 2: x = -6 + 0 = -6; y = 1 → now r1=0, r2 = -(-6)=6? No, wait: r2 should be -x? x=-6 → -x = 6\n\nBut we want ranking to decrease. From (1, 0) to (0, 6) — this is a decrease lexicographically? Yes: (1,0) > (0,6), because first component decreases.\n\nSo lexicographic order: (1, *) > (0, *)\n\nSo yes, switching from phase y≤0 to y>0 causes a drop in the first component.\n\nBut in the y≤0 phase, we must ensure the ranking decreases.\n\nWhile y ≤ 0:\n  State: (1, k), where k = -y ≥ 0\n  After step: y increases by 1 → new y' = y+1 → new k' = -y' = -y -1 = k -1\n  So (1, k) → (1, k-1): strictly decreases.\n\nThen when y becomes 1: (1,0) → (0, -x'), which is less.\n\nThen in y > 0 phase:\n  x increases by y (≥1) → x grows → -x decreases\n  But: we are using (0, -x) as ranking? But -x may increase if x is negative and growing (e.g., from -10 to -5): -x goes from 10 to 5 → decreases? Yes.\n\n  Wait: if x is negative and increasing (say from -10 to -5), then -x decreases from 10 to 5.\n\n  But our guard is x < 0 → we only stay in loop while x < 0.\n\n  So as long as x < 0, -x > 0, and as x increases (toward 0), -x decreases.\n\n  And since x eventually becomes ≥0, -x will eventually become ≤0, and we exit.\n\n  But: if x jumps over 0 (e.g., from -2 to 1), then we exit.\n\n  So in phase y>0, we can use -x as the secondary ranking.\n\n  However, in the tuple (phase_flag, -x), the first component is now 0, and second is -x, which is strictly decreasing as x increases.\n\nBut wait: in the first phase, ranking is (1, -y), and in second phase (0, -x). These are different quantities.\n\nIs this lexicographically well-founded? Yes, because:\n  - Domain is N² with lex order.\n  - Each transition leads to a smaller tuple.\n\nHowever, we must handle the case when y starts positive.\n\nAlso note: when y ≤ 0, we use (1, -y); when y > 0, we use (0, -x).\n\nBut what if during y ≤ 0 phase, x becomes very negative? That’s okay — we don’t care about x yet; we’re waiting for y to become positive.\n\nSo the ranking function can be defined as:\n\n  f(x,y) =\n      if y ≤ 0: (1, -y)\n      if y > 0: (0, -x)\n\nBut we must verify that it decreases at each step.\n\nCase 1: y < 0 (so y ≤ 0 and y ≠ 0)\n    Before: state has f = (1, -y)\n    After: y' = y+1 → still ≤ 0 or >0?\n        If y+1 ≤ 0 → then new f = (1, -(y+1)) = (1, -y -1) < (1, -y) ✅\n        If y+1 = 1 (i.e., y=0) → but we assumed y<0 → y+1=0 possible\n        So if y = -1 → y'=0 → still ≤0 → f = (1""}","```yaml analysis: |   We are analyzing the loop:       while (x < 0) {           x = x + y;           y = y + 1;       }    Variables: x, y   Guard condition: x < 0    We need to determine whether thi"
2026-01-16T20:39:53.772144,rf_template_Balanced,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template,qwenplus,qwen-plus,0.7,0.9,,40868.74,274,1702,1976,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct phases: (1) when y ≤ 0, where y increases monotonically until positive; (2) when y > 0, where x receives increasing positive increments and eventually becomes non-negative. A multi-phase ranking function captures this behavior naturally, with one component per phase.""}","```yaml analysis: |   The loop condition is (x < 0), and inside the loop:     x = x + y     y = y + 1    We analyze how the variables evolve:   - y increases by 1 in each iteration → strictly increasi"
2026-01-16T20:40:21.347006,rf_template_Creative,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template,qwenplus,qwen-plus,1.0,1.0,,27569.84,274,1105,1379,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct phases: first, y increases until it becomes positive (even if x decreases); second, with y > 0, x increases monotonically and will eventually violate the guard x < 0. A multi-phase ranking function with two phases captures this behavior.""}","```yaml analysis: |   We are analyzing the loop:          while (x < 0) {           x = x + y;           y = y + 1;       }    Variables: x, y   Guard condition: x < 0    Let's analyze the behavior:  "
2026-01-16T20:40:22.601678,rf_template_autoverus_seahorn_v1_Deterministic,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.0,1.0,,1253.73,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:40:24.019651,rf_template_autoverus_seahorn_v1_Balanced,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.7,0.9,,1417.05,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:40:25.071680,rf_template_autoverus_seahorn_v1_Creative,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,1.0,1.0,,1051.08,237,15,252,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:40:45.607143,rf_template_fewshot_Deterministic,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_fewshot,qwenplus,qwen-plus,0.0,1.0,,20533.16,485,785,1270,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two-phase behavior: first y increases to 0, then x increases rapidly due to cumulative y; each phase has a distinct progress metric.""}","```yaml analysis: |   The loop condition is (x < 0), so termination requires x to eventually become >= 0.   However, x is updated as x = x + y, and y is incremented by 1 each iteration (y = y + 1).   "
2026-01-16T20:41:22.098695,rf_template_fewshot_Balanced,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_fewshot,qwenplus,qwen-plus,0.7,0.9,,36485.66,485,1257,1742,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""Uniform loop dynamics with guaranteed termination due to quadratic growth in x; a single ranking function (possibly nonlinear) suffices.""}","```yaml analysis: |   The loop condition is (x < 0), so termination depends on x eventually becoming >= 0.   In each iteration:     - x is updated to x + y     - y is incremented by 1    Without any i"
2026-01-16T20:41:57.595093,rf_template_fewshot_Creative,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_fewshot,qwenplus,qwen-plus,1.0,1.0,,35490.11,485,1312,1797,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two logical phases: (1) y ≤ 0 — y increases toward positivity while x may regress; (2) y > 0 — x receives increasing positive increments ensuring escape from negativity. No branching, but semantic shift in dynamics justifies multi-phase analysis.""}","```yaml analysis: |   The loop condition is (x < 0), so termination depends on x eventually becoming >= 0.   Within the loop:     - x is updated as x = x + y     - y is incremented by 1: y = y + 1    "
2026-01-17T01:57:32.682825,rf_template_Deterministic,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template,qwenmax,qwen3-max,0.0,1.0,,38699.29,274,1423,1697,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two phases: initially y may be small or negative, causing x to possibly decrease, but once y becomes sufficiently large, x increases monotonically toward non-negative values. A multi-phase ranking function with depth 2 captures this behavior.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y is incremented by 1 each iteration: y := y + 1.    Observe that y increases monotonically. There"
2026-01-17T01:58:26.913651,rf_template_Balanced,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template,qwenmax,qwen3-max,0.7,0.9,,54224.5,274,1960,2234,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct phases: (1) while y ≤ 0, x may decrease but y increases, bounding this phase; (2) once y > 0, x increases monotonically to termination. A multi-phase template with depth 2 captures these behaviors.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y is incremented by 1 each iteration: y := y + 1.    Observe that y increases monotonically. This "
2026-01-17T01:58:45.997352,rf_template_Creative,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template,qwenmax,qwen3-max,1.0,1.0,,19080.7,274,534,808,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two phases: initially y may be non-positive and x could decrease, but y increases each iteration; once y becomes positive, x increases toward non-negativity. A 2-phase ranking function captures this behavior.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y and y is incremented by 1 each iteration: y := y + 1.    Observe that y increases monotonically. Howeve"
2026-01-17T01:58:48.876210,rf_template_autoverus_seahorn_v1_Deterministic,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.0,1.0,,2877.85,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:58:50.147792,rf_template_autoverus_seahorn_v1_Balanced,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.7,0.9,,1270.61,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:58:51.679884,rf_template_autoverus_seahorn_v1_Creative,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,1.0,1.0,,1531.12,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:59:35.609693,rf_template_fewshot_Deterministic,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_fewshot,qwenmax,qwen3-max,0.0,1.0,,43924.03,485,1542,2027,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first while y ≤ 0 (ranked by -y), then while y > 0 and x < 0 (ranked by -x).""}","```yaml analysis: |   The loop condition is (x < 0), so the loop continues while x is negative.   In each iteration:     x := x + y     y := y + 1    Since y increases by 1 each time, it grows without"
2026-01-17T02:00:07.573449,rf_template_fewshot_Balanced,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_fewshot,qwenmax,qwen3-max,0.7,0.9,,31959.59,485,867,1352,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first y increases until it becomes positive, then x increases monotonically to exit. A multi-phase template captures this shift in progress measure.""}","```yaml analysis: |   The loop condition is (x < 0), so the loop continues while x is negative.   In each iteration:     x := x + y     y := y + 1    Since y increases by 1 every iteration, it grows w"
2026-01-17T02:01:01.407254,rf_template_fewshot_Creative,86_pmt_yamlv2_extract.yml,loop_invariants/code2inv/86.c,,1,rf_template_fewshot,qwenmax,qwen3-max,1.0,1.0,,53828.02,485,1547,2032,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first y increases to 0 (with -y decreasing), then x increases to 0 (with -x decreasing).""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y := y + 1.   Initially, if x < 0, the loop runs. Note that y increases by 1 each iteration, so y "
