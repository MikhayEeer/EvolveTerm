timestamp,experiment_name,target_file,source_path,source_file,loop_id,prompt_version,config_tag,model,temperature,top_p,max_tokens,latency_ms,prompt_tokens,completion_tokens,total_tokens,template_type,template_depth,parsed_configuration,raw_response_snippet
2026-01-16T17:19:23.596398,rf_template_Deterministic,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template,glm47,glm-4.7,0.0,1.0,,17852.55,267,1055,1322,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""A single ranking function $r = -(x + y)$ is sufficient. As $y$ increases (which it must do), the value of $x+y$ increases, meaning $-(x+y)$ decreases, proving termination. Thus, a lexicographic order with depth 1 applies.""}","analysis: |   The loop condition is `x < 0`. Inside the loop, variable `x` is updated as `x = x + y`, and `y` is incremented by 1 (`y = y + 1`).   We need to determine if the variables decrease so the"
2026-01-16T17:19:27.647225,rf_template_Balanced,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template,glm47,glm-4.7,0.7,0.9,,4049.65,267,255,522,lnested,1,"{""type"": ""lnested"", ""depth"": 1, ""explanation"": ""The variable y strictly increases by 1 in every iteration (y' = y + 1), providing a direct measure of progress towards termination.""}","```yaml analysis: |   The loop condition is `x < 0`. Inside the loop, `x` is updated to `x + y` and `y` is updated to `y + 1`.   We can observe that the value of `y` strictly increases by 1 in every i"
2026-01-16T17:19:34.316511,rf_template_Creative,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template,glm47,glm-4.7,1.0,1.0,,6666.97,267,392,659,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Requires multi-phase ranking because `y` monotonically increases while `x`'s progress depends on the sign of `y`. Phase 1 handles the period where `y < 0` (progress via `-y`), and Phase 2 handles `x >= 0` (progress via `-x`).""}","```yaml analysis: |   The loop condition is `x < 0`, so termination depends on `x` becoming non-negative.   Inside the loop, `x` is updated as `x + y` and `y` is updated as `y + 1`.   The change in `x"
2026-01-16T17:19:38.601004,rf_template_autoverus_seahorn_v1_Deterministic,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.0,1.0,,4283.51,230,14,244,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T17:19:39.665436,rf_template_autoverus_seahorn_v1_Balanced,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,0.7,0.9,,1063.5,230,14,244,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T17:19:40.801726,rf_template_autoverus_seahorn_v1_Creative,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_autoverus_seahorn_v1,glm47,glm-4.7,1.0,1.0,,1135.17,230,14,244,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T17:19:45.498282,rf_template_fewshot_Deterministic,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_fewshot,glm47,glm-4.7,0.0,1.0,,4694.44,475,261,736,lnested,2,"{""type"": ""lnested"", ""depth"": 2, ""explanation"": ""Coupled linear updates on multiple variables; requires two components for sufficient ordering.""}","analysis: |   The loop iterates while $x < 0$. Inside, $x$ is updated as $x' = x + y$, and $y'$ = $y + 1$.   This is a linear transformation where $y$ increases by 1 each step. Although $x$ may increa"
2026-01-16T17:19:51.823706,rf_template_fewshot_Balanced,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_fewshot,glm47,glm-4.7,0.7,0.9,,6323.22,475,300,775,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: Phase 1 increases y until it is non-negative; Phase 2 increases x until the loop condition is false.""}","analysis: |   The loop condition is `x < 0`. Inside the loop, `x` is updated to `x + y` and `y` is incremented by 1.   Let's analyze the behavior:   - If `y` is positive, `x` increases (becomes less n"
2026-01-16T17:19:55.409200,rf_template_fewshot_Creative,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_fewshot,glm47,glm-4.7,1.0,1.0,,3583.97,475,173,648,,,{},"analysis: |   The loop continues while x is negative. In the loop body, x is updated by adding y (x + y) and y is incremented (y + 1).   Assuming initial y > 0 (which is necessary for termination to m"
2026-01-16T20:32:12.354968,rf_template_Deterministic,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template,qwenplus,qwen-plus,0.0,1.0,,30194.42,274,1370,1644,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct phases: first while y < 0 (where y increases toward 0), and second while y >= 0 and x < 0 (where x increases super-linearly). A multi-phase ranking function with depth 2 captures these phases separately, ensuring termination.""}","```yaml analysis: |   The loop condition is (x < 0), and the body updates:       x = x + y       y = y + 1    We analyze the behavior of the variables:    - y increases by 1 in each iteration, so y is"
2026-01-16T20:32:58.158327,rf_template_Balanced,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template,qwenplus,qwen-plus,0.7,0.9,,45796.55,274,2048,2322,,,"{""analysis"": ""We analyze the loop:\n\n    while (x < 0) {\n        x = x + y;\n        y = y + 1;\n    }\n\nVariables: x and y. The loop continues as long as x < 0.\n\nLet’s examine how the variables evolve:\n- In each iteration:\n    x_next = x + y\n    y_next = y + 1\n\nSo y increases by 1 every iteration → y is monotonically increasing.\nThe increment to x is y, which itself is increasing → x grows super-linearly (quadratically over iterations).\n\nSuppose we denote the values at iteration k:\n    y_k = y_0 + k\n    x_k = x_0 + y_0 + (y_0 + 1) + (y_0 + 2) + ... + (y_0 + k - 1)\n         = x_0 + k*y_0 + (0 + 1 + ... + (k-1))\n         = x_0 + k*y_0 + k*(k-1)/2\n\nThis is a quadratic in k, so eventually x_k will exceed 0, regardless of initial x_0 and y_0 (as long as the loop runs), because the quadratic term dominates.\n\nHowever, for termination analysis, we are interested in finding a ranking function.\n\nSince both x and y change, and x depends on y, but y increases steadily, we can consider a lexicographic ranking function.\n\nConsider candidate components:\n  - y increases monotonically → not suitable alone as a decreasing measure.\n  - But the distance from x to 0 (i.e., -x when x < 0) may not decrease monotonically — if y is negative initially, x might decrease first.\n\nWait: the loop condition is x < 0. For the loop to terminate, x must eventually become ≥ 0.\n\nBut what if y is negative and large in magnitude?\nExample: x = -1, y = -100\n    Iteration 1: x = -1 + (-100) = -101; y = -99 → still x < 0\n    Iteration 2: x = -101 + (-99) = -200; y = -98\n    x becomes more negative → diverges!\n\nSo the loop does **not** always terminate.\n\nBut wait — is that correct?\n\nActually, if y starts negative, it increases by 1 each time (towards zero and beyond). Eventually, y will become positive. But even before then, we need to check whether x can catch up.\n\nLet's suppose:\n    x₀ = -10, y₀ = -3\n\n    Step 1: x = -10 -3 = -13; y = -2\n    Step 2: x = -13 -2 = -15; y = -1\n    Step 3: x = -15 -1 = -16; y = 0\n    Step 4: x = -16 + 0 = -16; y = 1\n    Step 5: x = -16 + 1 = -15; y = 2\n    Step 6: x = -15 + 2 = -13; y = 3\n    Step 7: x = -13 + 3 = -10; y = 4\n    Step 8: x = -10 + 4 = -6; ...\n    Step 9: x = -6 + 5 = -1\n    Step10: x = -1 + 6 = 5 → exit.\n\nSo even with negative y, eventually y becomes positive and starts increasing x.\n\nNow, is termination guaranteed for all integer initial values?\n\nLet’s suppose at some point y ≥ 0. Then:\n    x_{k+1} = x_k + y_k ≥ x_k   (since y_k ≥ 0)\n\nSo once y ≥ 0, x is non-decreasing.\n\nAnd once y > 0, x increases by at least 1 per step, so eventually x ≥ 0.\n\nBut what if y never becomes positive? It does — since y increases by 1 every iteration, starting from any finite y₀, after a finite number of steps y will reach 0, then 1, etc.\n\nTherefore, regardless of initial x and y (integers), the loop **always terminates**.\n\nNow, for a ranking function.\n\nIdea: use a lexicographic ranking function where:\n  - First component: something related to y (but y increases — not decreasing).\n  - Instead, think about progress toward y becoming positive and then x growing.\n\nAlternatively, note that the number of iterations until y ≥ 0 is finite: max(0, -y₀ + 1) steps.\n\nAfter that, x increases by at least 1 per step (since y ≥ 1), and x < 0 is bounded above (say x ≤ -1), so the total number of steps after y ≥ 1 is at most |x| at that point.\n\nBut this suggests two phases:\n  Phase 1: y < 0 → x may decrease, but y increases.\n  Phase 2: y ≥ 0 → x increases.\n\nSo we can model this as a multi-phase ranking function.\n\nHowever, can we find a single lexicographic function?\n\nTry a lexicographic tuple:\n\n  f = (c - y, d - x)\n\nBut y increases, so -y decreases — good.\n\nBut x may decrease initially, so -x may increase — bad.\n\nAlternative idea: use the eventual \""potential\"" for growth.\n\nKnown technique: for loops where a variable increases linearly and affects another quadratically, use a ranking function based on the number of steps needed.\n\nHowever, simpler: observe that y increases without bound, and eventually x increases to 0.\n\nAnother approach: use a lexicographic ranking function where:\n  Component 1: an upper bound on how long y can stay negative → essentially -y (when y < 0)\n  But after y ≥ 0, we care about -x.\n\nBut we cannot switch arbitrarily.\n\nInstead, define a lexicographic function with two components:\n  f = (y_bound - y, x_target - x)\n\nNot straightforward.\n\nAlternatively, consider that the total number of iterations is bounded by a function of initial y and x.\n\nBut for SVMRanker, we want a template.\n\nInsight: although x can decrease initially, y is strictly increasing. So we can rank by a function that captures “progress” in y and residual work in x.\n\nConsider using a lexicographic ranking function:\n  f = (-y, -x)\n\nBut -y decreases (good), but -x can increase (bad) — not monotonic.\n\nHow about:\n  f = (K - y, M - x)\n\nStill same issue.\n\nBetter: since y increases by 1 each time, and eventually x will start increasing, we can use a multi-phase (lmulti) ranking.\n\nSpecifically:\n  - Phase 1: while y < 0 → we know y is increasing toward 0. Rank by (-y) — decreases to 0.\n  - Phase 2: while y >= 0 and x < 0 → now x increases by y (≥0) and y increases → x increases by at least 0, but once y ≥ 1, x increases by ≥1. So rank by (-x) — decreases to 0.\n\nBut during phase 1, x may decrease, so we don’t care — phase 1 ends when y reaches 0.\n\nSo lmulti with depth 2 (two phases) works.\n\nHowever, can we do it with lnested?\n\nTry a lexicographic tuple:\n  f = (φ₁, φ₂)\n\nLet φ₁ = -y   → decreases by 1 each iteration? No: y increases → -y decreases by 1 → strictly decreasing.\n\nBut the second component: we want to capture x.\n\nBut x can go down → so we cannot require φ₂ to decrease.\n\nHowever, in positions where φ₁ is unchanged (impossible — φ₁ changes every step), so we don't need to worry.\n\nBut for lexicographic order, we only require that either φ₁ decreases, or φ₁ stays same and φ₂ decreases.\n\nHere, φ₁ = -y decreases by exactly 1 every iteration → so the first component decreases every time → sufficient for ranking.\n\nWait! If the first component of a lexicographic tuple decreases on every iteration, then the whole tuple decreases lexicographically — regardless of other components.\n\nSo set:\n    f = (-y, anything)\n\nBut -y decreases → so f decreases lexicographically.\n\nBut is -y a valid ranking component? It must be mapped to a well-founded domain.\n\nBut -y may not be bounded below — if y starts very negative, -y is large positive, and decreases to smaller values → yes, it’s decreasing over integers.\n\nHowever, ranking functions must map to ordinals (well-founded), typically non-negative integers or tuples thereof.\n\nBut -y could be negative (if y > 0).\n\nExample: y = 5 → -y = -5 → not suitable as a ranking value (must be non-negative).\n\nSo we need a non-negative measure.\n\nInstead, consider: if we knew an upper bound K such that y ≤ K, then K""}",```yaml analysis: |   We analyze the loop:        while (x < 0) {           x = x + y;           y = y + 1;       }    Variables: x and y. The loop continues as long as x < 0.    Let’s examine how the
2026-01-16T20:33:41.814313,rf_template_Creative,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template,qwenplus,qwen-plus,1.0,1.0,,43649.37,274,1832,2106,lnested,2,"{""type"": ""lnested"", ""depth"": 2, ""explanation"": ""The loop requires two levels of reasoning: first, y increases monotonically until it becomes positive (captured by max(0, -y)), ensuring eventual entry into a regime where x increases rapidly. Second, once y > 0, x grows quadratically, guaranteeing termination. A lexicographic ranking function with two components captures this phased but continuous progress.""}","```yaml analysis: |   The loop runs while x < 0, and in each iteration:     - x is updated to x + y     - y is updated to y + 1    Let's analyze the behavior of the variables:    - y increases by 1 in"
2026-01-16T20:33:42.911265,rf_template_autoverus_seahorn_v1_Deterministic,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.0,1.0,,1096.14,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:33:44.047715,rf_template_autoverus_seahorn_v1_Balanced,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,0.7,0.9,,1135.45,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-16T20:33:45.234023,rf_template_autoverus_seahorn_v1_Creative,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_autoverus_seahorn_v1,qwenplus,qwen-plus,1.0,1.0,,1185.76,237,19,256,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","```yaml configuration:   type: ""lnested""   depth: 1 ```"
2026-01-16T20:34:02.456055,rf_template_fewshot_Deterministic,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_fewshot,qwenplus,qwen-plus,0.0,1.0,,17218.38,485,714,1199,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two distinct phases: (1) y increases to positivity, during which x may not progress; (2) x increases under growing increments until loop exits.""}","```yaml analysis: |   The loop condition is (x < 0), so termination depends on x eventually becoming >= 0.   In each iteration:     - x is updated to x + y     - y is incremented by 1    Initially, if"
2026-01-16T20:34:38.773005,rf_template_fewshot_Balanced,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_fewshot,qwenplus,qwen-plus,0.7,0.9,,36311.55,485,1544,2029,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop has two distinct phases: first, y increases from negative values to positive (possibly causing x to decrease), and second, x increases quadratically until it reaches 0. A multi-phase ranking is needed because x does not decrease monotonically and different variables drive progress in each phase.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x = x + y, and y is incremented by 1.   There are no provided invariants, so we analyze possible behaviors.    Not"
2026-01-16T20:34:52.868432,rf_template_fewshot_Creative,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_fewshot,qwenplus,qwen-plus,1.0,1.0,,14092.4,485,553,1038,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two distinct phases: first y increases through negative values, then x increases to exit the loop. Different variables dominate progress in each phase.""}","```yaml analysis: |   The loop condition is (x < 0), so termination requires x to eventually become >= 0.   In each iteration, x is updated as x = x + y, and y is incremented by 1.   There are no know"
2026-01-17T01:49:49.841983,rf_template_Deterministic,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template,qwenmax,qwen3-max,0.0,1.0,,62180.01,274,2280,2554,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits two distinct phases: (1) while y < 0, y increases (so -y decreases); (2) once y ≥ 0, x increases until termination. A multi-phase ranking function with depth 2 captures this behavior.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y is incremented by 1 each iteration: y := y + 1.    Observe that y increases monotonically. Howev"
2026-01-17T01:51:17.368968,rf_template_Balanced,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template,qwenmax,qwen3-max,0.7,0.9,,87518.43,274,2928,3202,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop exhibits multi-phase behavior: initially, x may decrease while y increases; once y becomes sufficiently large, x increases toward termination. No single linear ranking function exists, but a multi-phase template of depth 2 can capture the two stages of progress.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y is incremented by 1 each iteration: y := y + 1.    We need to determine whether this loop termin"
2026-01-17T01:52:16.384881,rf_template_Creative,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template,qwenmax,qwen3-max,1.0,1.0,,59007.59,274,2170,2444,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""The loop has two phases: (1) y ≤ 0, where y increases (so -y decreases); (2) y > 0, where x increases by at least 1 each iteration (so -x decreases). A multi-phase ranking function with depth 2 captures this behavior.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y and y is incremented by 1 each iteration: y := y + 1.    Let's examine the behavior:   - y increases mo"
2026-01-17T01:52:18.928768,rf_template_autoverus_seahorn_v1_Deterministic,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.0,1.0,,2542.93,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:52:20.581907,rf_template_autoverus_seahorn_v1_Balanced,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,0.7,0.9,,1652.19,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:52:22.430776,rf_template_autoverus_seahorn_v1_Creative,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_autoverus_seahorn_v1,qwenmax,qwen3-max,1.0,1.0,,1847.92,237,14,251,lnested,1,"{""type"": ""lnested"", ""depth"": 1}","configuration:   type: ""lnested""   depth: 1"
2026-01-17T01:52:50.137272,rf_template_fewshot_Deterministic,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_fewshot,qwenmax,qwen3-max,0.0,1.0,,27702.62,485,688,1173,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first y increases while possibly making x more negative; second, y > 0 ensures x increases to exit.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x + y, and y is incremented by 1 each iteration.   Since y increases every iteration, eventually y will become lar"
2026-01-17T01:53:13.513850,rf_template_fewshot_Balanced,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_fewshot,qwenmax,qwen3-max,0.7,0.9,,23373.23,485,695,1180,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first y increases (so -y decreases) while y < 0; then x increases (so -x decreases) once y ≥ 0.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y := y + 1.   Since y increases by 1 each iteration, it grows without bound if the loop runs long "
2026-01-17T01:53:32.187526,rf_template_fewshot_Creative,84_pmt_yamlv2_extract.yml,loop_invariants/code2inv/84.c,,1,rf_template_fewshot,qwenmax,qwen3-max,1.0,1.0,,18670.25,485,556,1041,lmulti,2,"{""type"": ""lmulti"", ""depth"": 2, ""explanation"": ""Two phases: first y increases (possibly while x stagnates or worsens), then x increases to exit. A multi-phase ranking function captures this staged progress.""}","```yaml analysis: |   The loop condition is (x < 0). Inside the loop, x is updated as x := x + y, and y := y + 1.   Since y increases by 1 each iteration, it will eventually become positive and keep g"
