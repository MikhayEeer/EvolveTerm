You are an expert in termination analysis.
The provided C code is **KNOWN TO BE TERMINATING**.
Your task is to determine the **simplest** ranking function template required to prove it, for use with SVMRanker.

### 1. Classification Priority
You must choose the simplest sufficient type.
**Priority**: Single Phase (Depth 1) > Nested (lnested) > Multi-phase (lmulti).

- **Single/Simple**: Can be proved by one linear function? -> type="lnested", depth=1.
- **Nested**: Requires lexicographic order or dependencies? -> type="lnested", depth=k.
- **Multi-phase**: Requires distinct phases (e.g. x decreases, then y decreases)? -> type="lmulti", depth=k.

### 2. Instructions
1. **Analyze**: Why does this code terminate?
2. **Classify**: What is the minimum complexity needed?
3. **Output**: Return the YAML object.

### 3. Format Rules
Output the result in **YAML** format with two keys: `analysis` and `configuration`.
- `analysis`: A block string containing your reasoning.
- `configuration`: An object containing the tool settings.

**YAML Structure**:
```yaml
analysis: |
  ### Analysis
  The loop terminates because...
configuration:
  type: "lnested|lmulti"
  depth: 1
  explanation: "Reasoning for classification."
```

### 4. Examples

**Example 1: Simple Counter (Depth 1)**
Target code:
```c
int i = 0;
int n = 100;
while (i < n) {
    i++;
}
```
Identified Loop Invariants:
["i >= 0", "i <= n"]

Output:
```yaml
analysis: |
  ### Analysis
  This loop is KNOWN to terminate.
  Variable `i` monotonically increases from 0 towards `n`.
  The ranking function f(i) = n - i strictly decreases:
  - Initial: f(0) = 100
  - After one iteration: f(1) = 99
  - Bounded below: f(i) >= 0 when i <= n
  This is the simplest case requiring only depth 1.
configuration:
  type: "lnested"
  depth: 1
  explanation: "Single variable with linear decrease. Simplest template suffices."
```

**Example 2: Nested Dependency (Depth 2)**
Target code:
```c
int q = 100;
int y = 1;
while (q > 0) {
    q = q - y;
    y = y + 1;
}
```
Identified Loop Invariants:
["q > 0 implies y <= 100", "y > 0"]

Output:
```yaml
analysis: |
  ### Analysis
  This loop is KNOWN to terminate.
  Variable `q` decreases, but the decrement step `y` increases.
  Cannot use single function f(q) = q alone because:
  - When y=1: q decreases by 1
  - When y=2: q decreases by 2 (faster)
  Need lexicographic ranking (q, -y):
  - Primary: q decreases (overall progress)
  - Secondary: when q unchanged, y increases (inner progress)
  This is nested (lexicographic), requires depth 2.
  NOT multi-phase because there's no phase switching.
configuration:
  type: "lnested"
  depth: 2
  explanation: "Lexicographic order handles dependent decrease rates. Depth 1 insufficient."
```

**Example 3: Multi-phase (Depth 2)**
Target code:
```c
int x = 10;
int y = 20;
while (x > 0 || y > 0) {
    if (y > 0) {
        x = x + y - 1;
        y = y - 1;
    } else {
        x = x - 1;
    }
}
```
Identified Loop Invariants:
["x + y > 0 when loop active"]

Output:
```yaml
analysis: |
  ### Analysis
  This loop is KNOWN to terminate.
  It exhibits distinct phases:
  - **Phase 1** (y > 0): Decrease y to 0. Note x may INCREASE here!
  - **Phase 2** (y = 0): Decrease x to 0.
  
  Why not nested? 
  - Lexicographic (x, y) fails: x can increase in Phase 1
  - Lexicographic (y, x) also fails: wrong priority
  
  Must use multi-phase:
  - Phase 1 ranking: y (decreases to 0)
  - Phase 2 ranking: x (decreases to 0 once y=0)
  - Phase condition: y = 0 triggers phase switch
  
  This is the simplest multi-phase case, depth 2.
  Nested templates (any depth) cannot handle this.
configuration:
  type: "lmulti"
  depth: 2
  explanation: "Sequential phases with phase switching. Nested insufficient; multi-phase required."
```

### 5. Key Decision Criteria

**When to choose lnested depth 1:**
- Single variable dominates (e.g., counter i++ towards n)
- No complex dependencies

**When to choose lnested depth > 1:**
- Multiple variables with lexicographic order
- Variables depend on each other but all monotonically progress
- No phase switching behavior

**When to choose lmulti:**
- Clear phase boundaries (if-else structure changing behavior)
- One variable can INCREASE while another decreases
- Phase condition triggers different ranking function
